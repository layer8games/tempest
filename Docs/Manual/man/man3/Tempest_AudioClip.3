.TH "Tempest::AudioClip" 3 "Mon Mar 2 2020" "Tempest" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Tempest::AudioClip \- A wrapper around an OpenAL audio buffer\&. This stores a clip of audio that, after added to an \fBAudioSource\fP, can be played\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <AudioClip\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBChunkHeader\fP"
.br
.ti -1c
.RI "struct \fBFormatInfo\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "TEMPEST_API \fBAudioClip\fP (void)"
.br
.RI "Calls \fBAudioManager::Instance\fP to make sure that the context and device has been set up in OpenAL before use\&. "
.ti -1c
.RI "TEMPEST_API \fB~AudioClip\fP (void)"
.br
.RI "Calls delete[] on the data array to free that resource\&. Deletes the buffer handle from OpenAL\&. "
.ti -1c
.RI "TEMPEST_API void \fBLoadWAV2\fP (string filename)"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetBufferID\fP (void) const"
.br
.RI "Returns the buffer handle from OpenAL\&. "
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBHeaderOffsets\fP { \fBNUM_CHANNELS_OFFSET\fP = 6, \fBCHANNELS_SIZE\fP = 2, \fBSAMPLE_RATE_OFFSET\fP = 8, \fBSAMPLE_RATE_SIZE\fP = 4, \fBBPS_OFFSET\fP = 18, \fBBPS_SIZE\fP = 2, \fBLIST_SIZE\fP = 2, \fBDATA_SIZE\fP = 4 }"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fB_IsBigEndian\fP (void)"
.br
.ti -1c
.RI "\fBU32\fP \fB_ConvertToInt\fP (char *buffer, int len)"
.br
.ti -1c
.RI "void \fB_GetIndexRange\fP (char *source, char *dest, int offset, int len)"
.br
.ti -1c
.RI "char * \fB_FindChunk\fP (char *fileBegin, char *fileEnd, \fBS32\fP desiredID, \fBS32\fP swapped)"
.br
.ti -1c
.RI "char * \fB_ChunkEnd\fP (char *chunkStart, \fBS32\fP swapped)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBU32\fP \fB_bufferID\fP"
.br
.RI "OpenAL buffer handle\&. This is the ID OpenAL uses, similar to OpenGL's handles\&. "
.ti -1c
.RI "char * \fB_data\fP"
.br
.RI "Data buffer for the file\&. This is the full file, headers included\&. "
.in -1c
.SH "Detailed Description"
.PP 
A wrapper around an OpenAL audio buffer\&. This stores a clip of audio that, after added to an \fBAudioSource\fP, can be played\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBU32\fP AudioClip::_ConvertToInt (char * buffer, int len)\fC [private]\fP"
Converts a bit buffer of a set length into its integar equivalent\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP are the bits to convert\&. 
.br
\fIlen\fP is the size of the buffer\&. This must match what you are expecting! 
.br
 
.RE
.PP

.SS "void AudioClip::_GetIndexRange (char * source, char * dest, int offset, int len)\fC [private]\fP"
An ad hoc solution to array slicing\&. It returns into the destination the elements of the source array from an offset by a set amount\&. For example, if source is an array with 100 elements, and offset is 10, with len being 10, then dest will be source elements 10 through 20\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource\fP is the original array we are slicing into\&. 
.br
\fIdest\fP is where the sub array from source will be stores\&. 
.br
\fIoffset\fP is how far into source to start slicing\&. 
.br
\fIlen\fP is how many elements past offset to slice into dest\&. 
.RE
.PP

.SS "bool Tempest::AudioClip::_IsBigEndian (void)\fC [inline]\fP, \fC [private]\fP"
Used to test how the bits of an int are arranged in the internal format of the machine the code is running on\&. Returns true if the machine is Big Endian, false if it is Little Endian\&. https://en.wikipedia.org/wiki/Endianness 
.SS "void AudioClip::LoadWAV2 (string filename)"
Reads a \&.wav file from the hard drive\&. Parses over the file extracting needed information from the headers, then saves the audio file in a buffer that is registered with OpenAL\&. This is used later to actually play back the file\&. This is where all the magic happens\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilename\fP is the path to the file to be read\&. Should live in \&.\&./Assets/Audio by convention\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Tempest from the source code\&.

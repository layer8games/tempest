.TH "KillerEngine::LevelManager" 3 "Mon Jun 24 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerEngine::LevelManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <LevelManager\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~LevelManager\fP (void)"
.br
.ti -1c
.RI "void \fBShutDown\fP (void)"
.br
.ti -1c
.RI "void \fBAddLevel\fP (p_Level level)"
.br
.ti -1c
.RI "void \fBRemoveLevel\fP (\fBU32\fP levelID)"
.br
.ti -1c
.RI "void \fBSetActiveLevel\fP (\fBU32\fP levelID)"
.br
.ti -1c
.RI "void \fBSetActiveLevel\fP (p_Level level)"
.br
.ti -1c
.RI "\fBU32\fP \fBGetActiveLevelID\fP (void)"
.br
.ti -1c
.RI "p_Level \fBGetActiveLevel\fP (void)"
.br
.ti -1c
.RI "void \fBEndGame\fP (void)"
.br
.ti -1c
.RI "void \fBAddObjectToLevel\fP (\fBU32\fP id, const \fBGameObject\fP &obj)"
.br
.ti -1c
.RI "void \fBAddObjectToLevel\fP (\fBU32\fP id, shared_ptr< \fBGameObject\fP > obj)"
.br
.ti -1c
.RI "void \fBRemoveObjectFromLevel\fP (\fBU32\fP levelID, \fBU32\fP objID)"
.br
.ti -1c
.RI "void \fBUpdate\fP (void)"
.br
.ti -1c
.RI "void \fBRender\fP (void)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBLevelManager\fP * \fBInstance\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBLevelManager\fP (void)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::map< \fBU32\fP, p_Level > \fB_levels\fP"
.br
.RI "Database of Levels that can be activated\&. "
.ti -1c
.RI "p_Level \fB_activeLevel\fP"
.br
.RI "Pointer to active \fBLevel\fP from database\&. "
.ti -1c
.RI "\fBU32\fP \fB_activeLevelID\fP"
.br
.RI "The ID of the active \fBLevel\fP\&. "
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBLevelManager\fP * \fB_instance\fP = NULL"
.br
.RI "Singletone pointer to global version of \fBLevelManager\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
The holder and controller of the the \fBLevel\fP objects\&. This will act as both a singleton and a state matching controller, where each \fBLevel\fP will be a state that can be set to active\&.
.PP
For now, all of the states that are to be used will be instantiated during the initialization in the main loop, however later, each \fBLevel\fP will only be created once it is called, as part of a loading screen\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "LevelManager::~LevelManager (void)"
No implementation\&. 
.SS "LevelManager::LevelManager (void)\fC [protected]\fP"
Sets active \fBLevel\fP state to a nullptr\&. 
.SH "Member Function Documentation"
.PP 
.SS "void LevelManager::AddLevel (p_Level level)"
Adds a \fBLevel\fP into the state machine that can then be set to active to be in use\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevel\fP is added into the database, with \fBLevel::GetID\fP used to index\&. 
.RE
.PP

.SS "void LevelManager::AddObjectToLevel (\fBU32\fP id, const \fBGameObject\fP & obj)"
Allows object to be added to level\&. Wrapper around \fBLevel::AddObjectToLevel\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the key for the \fBLevel\fP that the object will be added to\&. 
.br
\fIobj\fP is the object to add\&. 
.RE
.PP

.SS "void LevelManager::AddObjectToLevel (\fBU32\fP id, shared_ptr< \fBGameObject\fP > obj)"
Allows object to be added to level\&. Wrapper around \fBLevel::AddObjectToLevel\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the key for the \fBLevel\fP that the object will be added to\&. 
.br
\fIobj\fP is the object pointer to add\&. 
.RE
.PP

.SS "void KillerEngine::LevelManager::EndGame (void)\fC [inline]\fP"
Starts the process to shut down the game\&. Wrapper around \fBGameWindow::EndRunning\fP\&. 
.SS "p_Level KillerEngine::LevelManager::GetActiveLevel (void)\fC [inline]\fP"
Returns a pointer to the active \fBLevel\fP state\&. 
.SS "\fBU32\fP KillerEngine::LevelManager::GetActiveLevelID (void)\fC [inline]\fP"
Returns the ID of the active \fBLevel\fP state\&. 
.SS "\fBLevelManager\fP * LevelManager::Instance (void)\fC [static]\fP"
Singleton fucntion\&. Returns the global pointer used to access the manager\&. 
.SS "void LevelManager::RemoveLevel (\fBU32\fP levelID)"
Removes \fBLevel\fP from database\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevelID\fP is the index to delete\&. 
.RE
.PP

.SS "void LevelManager::RemoveObjectFromLevel (\fBU32\fP levelID, \fBU32\fP objID)"
Removes an object from a \fBLevel\fP\&. Wrapper around \fBLevel::RemoveObjectFromLevel\fP\&. This assumes that ID are unique for all \fBGameObject\fP\&. I don't know if this is true, so be careful\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevelID\fP is the key for the \fBLevel\fP that the object will be removed from\&. 
.br
\fIobjID\fP is the \fBGameObject\fP ID to remove\&. 
.RE
.PP

.SS "void LevelManager::Render (void)"
Calls all of the functions on the active \fBLevel\fP state needed to render the state\&. Calls \fBLevel::v_Render\fP\&. 
.SS "void LevelManager::SetActiveLevel (\fBU32\fP levelID)"
Changes the state to have a different active \fBLevel\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevelID\fP is the index to set to active\&. 
.RE
.PP

.SS "void LevelManager::SetActiveLevel (p_Level level)"
Changes the active level to be a new level\&. This level is NOT stored in the levels data base and will be deleted when the active level is changed again\&. This allows for levels to be lazy loaded, for quick switching, or to not be loaded into memory until they are set to active\&. \fBLevel::v_Init\fP is called before it is set to active\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevel\fP is the new \fBLevel\fP that will be set to active\&. 
.RE
.PP

.SS "void KillerEngine::LevelManager::ShutDown (void)\fC [inline]\fP"
Helper function that deletes the instance from global memory\&. 
.SS "void LevelManager::Update (void)"
Calls all functions on the active \fBLevel\fP state needed to update that state\&. This includes Level::v_Integrate, \fBLevel::UpdateLevel\fP, \fBLevel::UpdateObjects\fP and \fBLevel::v_Update\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

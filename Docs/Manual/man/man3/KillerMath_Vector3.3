.TH "KillerMath::Vector3" 3 "Sat Jun 1 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Vector3
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Vector3\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector3\fP (void)"
.br
.ti -1c
.RI "\fBVector3\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector3\fP (\fBF32\fP x, \fBF32\fP y)"
.br
.ti -1c
.RI "\fBVector3\fP (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
.br
.ti -1c
.RI "\fBVector3\fP (const \fBVector3\fP &v)"
.br
.ti -1c
.RI "\fBVector3\fP (const \fBVector4\fP &v)"
.br
.ti -1c
.RI "\fB~Vector3\fP (void)"
.br
.ti -1c
.RI "void \fBMake2D\fP (bool state=true)"
.br
.ti -1c
.RI "void \fBMake3D\fP (bool state=false)"
.br
.ti -1c
.RI "bool \fBIs2D\fP (void) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDot\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "\fBVector3\fP \fBCrossProduct\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "\fBF32\fP \fBMagnitude\fP (void)"
.br
.ti -1c
.RI "\fBF32\fP \fBSqrMagnitude\fP (void)"
.br
.ti -1c
.RI "void \fBNormalize\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (\fBF32\fP val=0\&.0f)"
.br
.ti -1c
.RI "void \fBAddScaledVector3\fP (const \fBVector3\fP &vec, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBF32\fP * \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBSet\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "const \fBF32\fP & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "\fBF32\fP & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator=\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator+\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator+=\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator+\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator+=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator+\fP (shared_ptr< \fBVector3\fP > vec) const"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator\-\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator\-=\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator\-\fP (void)"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator++\fP (void)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator\-\-\fP (void)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator\-\-\fP (int)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator\-\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator\-=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator*\fP (const \fBVector3\fP vec) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator*=\fP (const \fBVector3\fP vec)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator*\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator*=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector3\fP \fBoperator/\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator/=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBVector3\fP &vec) const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fB_2D\fP"
.br
.RI "Used to decide whether to use 2D or 3D logic in operators\&. "
.ti -1c
.RI "\fBF32\fP \fB_data\fP [3]"
.br
.RI "Array that stores the values for each element\&. "
.in -1c
.SH "Detailed Description"
.PP 
A custom \fBVector3\fP class writen for the Killer Engine\&.
.PP
The \fBVector3\fP is a 3 element 3D Vector\&. The \fBVector3\fP consists of an x, y, and z component represented by an array of F32 values\&. They are refered as x, y, and z through documentation\&. In code, you can refere to them by x, y and z, due to an enum defined in \fBAtom\&.h\fP\&. 
.br
 Unlike the \fBVector4\fP, there is no w, so there is no difference between a position and a direction, like in the \fBPoint\fP vs \fBVector4\fP classes\&. This class exists for when something doesn't need that extra data that comes with the w element\&. This can save on memory and computation\&. The \fBMatrix3\fP class uses it, for example\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Vector3::Vector3 (void)"
Default construtor\&. Sets all values to 0, and _2D to false\&. 
.SS "Vector3::Vector3 (\fBF32\fP val)\fC [explicit]\fP"
Single input conversion constructor\&. It will set the x, y and z components to the input\&. _2D is false\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP F32: Input value for x, y and z\&. 
.RE
.PP

.SS "Vector3::Vector3 (\fBF32\fP x, \fBF32\fP y)"
Two input constructor\&. Set's x and y accordingly\&. Z is set to 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.RE
.PP

.SS "Vector3::Vector3 (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
Three input constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.br
\fIz\fP is the value for z\&. 
.RE
.PP

.SS "Vector3::Vector3 (const \fBVector3\fP & v)"
Copy Constructor\&. It explicitly copies all data into new \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP is the \fBVector3\fP to copy\&. 
.RE
.PP

.SS "Vector3::Vector3 (const \fBVector4\fP & v)\fC [explicit]\fP"
Convert a \fBVector4\fP into a \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP is the \fBVector4\fP to convert\&. 
.RE
.PP

.SS "Vector3::~Vector3 (void)"
No implementation\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Vector3::AddScaledVector3 (const \fBVector3\fP & vec, \fBF32\fP scale)"
Adds a \fBVector3\fP scaled by a value to this \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP that will be added to this one\&. 
.br
\fIscale\fP is the amount the added \fBVector3\fP will be scaled by\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::CrossProduct (const \fBVector3\fP & vec) const"
Performs a Cross or \fBVector3\fP production in the order of this cross other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "\fBF32\fP Vector3::Dot (const \fBVector3\fP & vec) const"
Performs a Dot or Scalar product in the order of this * other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "const \fBF32\fP* KillerMath::Vector3::GetElems (void) const\fC [inline]\fP"
Returns the raw data for the \fBVector3\fP\&. 
.SS "bool KillerMath::Vector3::Is2D (void) const\fC [inline]\fP"
Returns that 2D state of the \fBVector3\fP stored in _2D; 
.SS "\fBF32\fP Vector3::Magnitude (void)"
Returns the length of the \fBVector3\fP\&. Caution, this uses the square root function\&. 
.SS "void KillerMath::Vector3::Make2D (bool state = \fCtrue\fP)\fC [inline]\fP"
Sets the \fBVector3\fP to act like a 2D \fBVector3\fP instead of a 3D \fBVector3\fP by setting _2D to true\&. This means that the z value wont be copied or used in operations\&. 
.SS "void KillerMath::Vector3::Make3D (bool state = \fCfalse\fP)\fC [inline]\fP"
Sets the \fBVector3\fP to act like a 3D \fBVector3\fP instead of a 3D \fBVector3\fP by settings _2D to true\&. This means that the z value will be copied and used in operations\&. 
.SS "void Vector3::Normalize (void)"
Changes the \fBVector3\fP into a unit \fBVector3\fP by converting its magnitude to exaclty 1\&.0\&. This is an expensive operation\&. 
.SS "bool Vector3::operator!= (const \fBVector3\fP & vec) const"
False equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are not equal to all elements of other \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP this \fBVector3\fP will be compared against\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator* (const \fBVector3\fP vec) const"
\fBVector3\fP multiplication\&. This is a componentwise multiplication, scaling one \fBVector3\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP multiplied by the new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator* (\fBF32\fP val) const"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBVector3\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by the new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator*= (const \fBVector3\fP vec)"
\fBVector3\fP multiplication\&. This is a componentwise multiplication, scaling one \fBVector3\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP multiplied by this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator*= (\fBF32\fP val)"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBVector3\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator+ (const \fBVector3\fP & vec) const"
\fBVector3\fP addtion\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP to add into a new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator+ (\fBF32\fP val) const"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into the elements of a new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator+ (shared_ptr< \fBVector3\fP > vec) const"
Shared Pointer addition\&. A helper to allow arithmetic with shared_ptr<Vector3>\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the shared_ptr<Vector3> that is added into each element of a new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP& KillerMath::Vector3::operator++ (void)\fC [inline]\fP"
Prefix, Adds 1 to each element of the \fBVector3\fP\&. If 2D, z is ignored\&. 
.SS "\fBVector3\fP KillerMath::Vector3::operator++ (int)\fC [inline]\fP"
Postfix, Adds 1 to each element of the \fBVector3\fP\&. If 2D, z is ignored\&. 
.SS "\fBVector3\fP & Vector3::operator+= (const \fBVector3\fP & vec)"
\fBVector3\fP addition equal\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP to add into this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator+= (\fBF32\fP val)"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into each element of this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator\- (const \fBVector3\fP & vec) const"
\fBVector3\fP subtraction\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP subtracted from the new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP KillerMath::Vector3::operator\- (void)\fC [inline]\fP"
Changes the sign of each element of the \fBVector3\fP\&. If 2D, z is not changed\&. 
.SS "\fBVector3\fP Vector3::operator\- (\fBF32\fP val) const"
Scalar subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from the new \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP& KillerMath::Vector3::operator\-\- (void)\fC [inline]\fP"
Prefix, Subtracts 1 to each element of the \fBVector3\fP\&. If 2D, z is ignored\&. 
.SS "\fBVector3\fP KillerMath::Vector3::operator\-\- (int)\fC [inline]\fP"
Postfix, Subtracts 1 to each element of the \fBVector3\fP\&. If 2D, z is ignored\&. 
.SS "\fBVector3\fP & Vector3::operator\-= (const \fBVector3\fP & vec)"
\fBVector3\fP subtraction\&. This is done componenetwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the Vector3ed subtractd from this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator\-= (\fBF32\fP val)"
Sclara subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from each element of this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP Vector3::operator/ (\fBF32\fP val) const"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar the new \fBVector3\fP is divided by\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator/= (\fBF32\fP val)"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar this \fBVector3\fP is divided by\&. 
.RE
.PP

.SS "bool Vector3::operator< (const \fBVector3\fP & vec) const"
Less than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than all elements of the other \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP this \fBVector3\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector3::operator<= (const \fBVector3\fP & vec) const"
Less than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than or equal to all elements of the other \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP this \fBVector3\fP will be compared against\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator= (const \fBVector3\fP & vec)"
Copy assignment from \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP to copy into this \fBVector3\fP\&. 
.RE
.PP

.SS "\fBVector3\fP & Vector3::operator= (\fBF32\fP val)"
Copy assignment from scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value all elements will be set to\&. 2D check is done before z is changed\&. 
.RE
.PP

.SS "bool Vector3::operator== (const \fBVector3\fP & vec) const"
Equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are equal to all elements of other \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP this \fBVector3\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector3::operator> (const \fBVector3\fP & vec) const"
Greater than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than all elements of the other \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP this \fBVector3\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector3::operator>= (const \fBVector3\fP & vec) const"
Greater than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than or equal to all elements of the other \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP this \fBVector3\fP will be compared against\&. 
.RE
.PP

.SS "const \fBF32\fP& KillerMath::Vector3::operator[] (int i) const\fC [inline]\fP"
Allows you to index into the \fBVector3\fP to read the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to read\&. 0 = x, 1 = y, 2 = z\&. 
.RE
.PP

.SS "\fBF32\fP& KillerMath::Vector3::operator[] (int i)\fC [inline]\fP"
Allows you to index into the \fBVector3\fP to change the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to change\&. 0 = x, 1 = y, 2 = z\&. 
.RE
.PP

.SS "void Vector3::Reset (\fBF32\fP val = \fC0\&.0f\fP)"
Sets all values to input\&. Does not check for _2D before changing z\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value x, y and z will get\&. Default value is 0\&. 
.RE
.PP

.SS "void KillerMath::Vector3::Set (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [inline]\fP"
A helper function to allow to quickly set x, y and z to different values\&. This is useful because it is only one function call instead of the 3 it would take to call [] for each element\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the value for x\&. 
.br
\fIyVal\fP is the vlaue for y\&. 
.br
\fIzVal\fP is the value for z\&. 
.RE
.PP

.SS "\fBF32\fP Vector3::SqrMagnitude (void)"
Returns the squard length of the \fBVector3\fP\&. It avoids the cost of the square root function\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

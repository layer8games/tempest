.TH "KillerMath::Vector" 3 "Thu Jan 10 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Vector
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Vector\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector\fP (void)"
.br
.ti -1c
.RI "\fBVector\fP (F32 val)"
.br
.ti -1c
.RI "\fBVector\fP (F32 x, F32 y)"
.br
.ti -1c
.RI "\fBVector\fP (F32 x, F32 y, F32 z)"
.br
.ti -1c
.RI "\fBVector\fP (F32 x, F32 y, F32 z, F32 w)"
.br
.ti -1c
.RI "\fBVector\fP (const \fBVector\fP &v)"
.br
.ti -1c
.RI "\fB~Vector\fP (void)"
.br
.ti -1c
.RI "void \fBMake2D\fP (void)"
.br
.ti -1c
.RI "void \fBMake3D\fP (void)"
.br
.ti -1c
.RI "bool \fBIs2D\fP (void) const"
.br
.ti -1c
.RI "F32 \fBDotProduct\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "\fBVector\fP \fBCrossProduct\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "F32 \fBMagnitude\fP (void)"
.br
.ti -1c
.RI "F32 \fBSqrMagnitude\fP (void)"
.br
.ti -1c
.RI "void \fBNormalize\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (F32 val=0\&.0f)"
.br
.ti -1c
.RI "void \fBAddScaledVector\fP (const \fBVector\fP &vec, F32 scale)"
.br
.ti -1c
.RI "const F32 * \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBSet\fP (F32 xVal, F32 yVal, F32 zVal)"
.br
.ti -1c
.RI "const F32 & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "F32 & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator=\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator=\fP (F32 val)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator+\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator+=\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator+\fP (F32 val) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator+=\fP (F32 val)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator+\fP (shared_ptr< \fBVector\fP > vec) const"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator\-\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator\-=\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator\-\fP (F32 val) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator\-=\fP (F32 val)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (const \fBVector\fP vec) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator*=\fP (const \fBVector\fP vec)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (F32 val) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator*=\fP (F32 val)"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator/\fP (F32 val) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator/=\fP (F32 val)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBVector\fP &vec) const"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBx\fP = 0, \fBy\fP = 1, \fBz\fP = 2, \fBw\fP = 3 }"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fB_2D\fP"
.br
.RI "Used to decide whether to use 2D or 3D logic in operators\&. "
.ti -1c
.RI "F32 \fB_data\fP [4]"
.br
.RI "Array that stores the values for each element\&. "
.in -1c
.SH "Detailed Description"
.PP 
A custom \fBVector\fP class writen for the Killer Engine\&.
.PP
The \fBVector\fP is a 4 element 3D vector\&. The \fBVector\fP consists of an x, y, z and w component represented by an array of F32 values\&. They are refered as x, y, z and w through through documentation\&. In code, you would have to refered to them as their index in the array (0 - 3)\&. There is an alias set up in the \fBVector\fP, and enum, that lets you use x, y, z and w to represent the indices natively\&. This is private to the \fBVector\fP\&. The w is included mostly used for convenience when multiplying with a 4X4 \fBMatrix\fP\&. It follows all the rules of a \fBVector\fP and can be used for what you need it to be\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum\fC [private]\fP"
Alias set up to allow a refernce to each element that is more human readable in the code\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Vector::Vector (void)"
Default construtor\&. Sets all values to 0, and _2D to false\&. 
.SS "Vector::Vector (F32 val)\fC [explicit]\fP"
Single input conversion constructor\&. It will set the x, y and z components to the input\&. _2D is false\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP F32: Input value for x, y and z\&. 
.RE
.PP

.SS "Vector::Vector (F32 x, F32 y)"
Two input constructor\&. Set's x and y accordingly\&. Z is set to 0\&.0f\&. W is set to 1\&.0f 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.RE
.PP

.SS "Vector::Vector (F32 x, F32 y, F32 z)"
Three input constructor\&. W is set to 1\&.0f\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.br
\fIz\fP is the value for z\&. 
.RE
.PP

.SS "Vector::Vector (F32 x, F32 y, F32 z, F32 w)"
Four input constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.br
\fIz\fP is the value for z\&. 
.br
\fIw\fP is the value for w\&. 
.RE
.PP

.SS "Vector::Vector (const \fBVector\fP & v)"
Copy Constructor\&. It explicitly copies all data into new \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP is the vector to copy\&. 
.RE
.PP

.SS "Vector::~Vector (void)"
Destructor\&. It does not do anything\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Vector::AddScaledVector (const \fBVector\fP & vec, F32 scale)"
Adds a \fBVector\fP scaled by a value to this \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the vector that will be added to this one\&. 
.br
\fIscale\fP is the amount the added vector will be scaled by\&. 
.RE
.PP

.SS "\fBVector\fP Vector::CrossProduct (const \fBVector\fP & vec) const"
Performs a Cross or \fBVector\fP production in the order of this % other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "F32 Vector::DotProduct (const \fBVector\fP & vec) const"
Performs a Dot or Scalar product in the order of this * other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "const F32* KillerMath::Vector::GetElems (void) const\fC [inline]\fP"
Returns the raw data for the \fBVector\fP\&. 
.SS "bool KillerMath::Vector::Is2D (void) const\fC [inline]\fP"
Returns that 2D state of the \fBVector\fP stored in _2D; 
.SS "F32 Vector::Magnitude (void)"
Returns the length of the \fBVector\fP\&. Caution, this uses the square root function\&. 
.SS "void KillerMath::Vector::Make2D (void)\fC [inline]\fP"
Sets the \fBVector\fP to act like a 2D vector instead of a 3D \fBVector\fP by setting _2D to true\&. This means that the z value wont be copied or used in operations\&. 
.SS "void KillerMath::Vector::Make3D (void)\fC [inline]\fP"
Sets the \fBVector\fP to act like a 3D \fBVector\fP instead of a 3D vector by settings _2D to true\&. This means that the z value will be copied and used in operations\&. 
.SS "void Vector::Normalize (void)"
Changes the \fBVector\fP into a unit vector by converting its magnitude to exaclty 1\&.0\&. This is an expensive operation\&. 
.SS "bool Vector::operator!= (const \fBVector\fP & vec) const"
False equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are not equal to all elements of other \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP this \fBVector\fP will be compared against\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator* (const \fBVector\fP vec) const"
\fBVector\fP multiplication\&. This is a componentwise multiplication, scaling one \fBVector\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP multiplied by the new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator* (F32 val) const"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBVector\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by the new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator*= (const \fBVector\fP vec)"
\fBVector\fP multiplication\&. This is a componentwise multiplication, scaling one \fBVector\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP multiplied by this \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator*= (F32 val)"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBVector\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by this \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator+ (const \fBVector\fP & vec) const"
\fBVector\fP addtion\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP to add into a new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator+ (F32 val) const"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into the elements of a new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator+ (shared_ptr< \fBVector\fP > vec) const"
Shared Pointer addition\&. A helper to allow arithmetic with shared_ptr<Vector>\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the shared_ptr<Vector> that is added into each element of a new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator+= (const \fBVector\fP & vec)"
\fBVector\fP addition equal\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP to add into this \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator+= (F32 val)"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into each element of this \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator\- (const \fBVector\fP & vec) const"
\fBVector\fP subtraction\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP subtracted from the new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator\- (F32 val) const"
Scalar subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from the new \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator\-= (const \fBVector\fP & vec)"
\fBVector\fP subtraction\&. This is done componenetwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the Vectored subtractd from this \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator\-= (F32 val)"
Sclara subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from each element of this \fBVector\fP\&. 
.RE
.PP

.SS "\fBVector\fP Vector::operator/ (F32 val) const"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar the new \fBVector\fP is divided by\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator/= (F32 val)"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar this \fBVector\fP is divided by\&. 
.RE
.PP

.SS "bool Vector::operator< (const \fBVector\fP & vec) const"
Less than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than all elements of the other \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP this \fBVector\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector::operator<= (const \fBVector\fP & vec) const"
Less than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than or equal to all elements of the other \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP this \fBVector\fP will be compared against\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator= (const \fBVector\fP & vec)"
Copy assignment from \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the vector to copy into this vector\&. 
.RE
.PP

.SS "\fBVector\fP & Vector::operator= (F32 val)"
Copy assignment from scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value all elements will be set to\&. w is not affect\&. 2D check is done before z is changed\&. 
.RE
.PP

.SS "bool Vector::operator== (const \fBVector\fP & vec) const"
Equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are equal to all elements of other \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP this \fBVector\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector::operator> (const \fBVector\fP & vec) const"
Greater than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than all elements of the other \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP this \fBVector\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector::operator>= (const \fBVector\fP & vec) const"
Greater than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than or equal to all elements of the other \fBVector\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector\fP this \fBVector\fP will be compared against\&. 
.RE
.PP

.SS "const F32& KillerMath::Vector::operator[] (int i) const\fC [inline]\fP"
Allows you to index into \fBVector\fP to read the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to read\&. 0 = x, 1 = y, 2 = z, 3 = w\&. 
.RE
.PP

.SS "F32& KillerMath::Vector::operator[] (int i)\fC [inline]\fP"
Allows you to index into \fBVector\fP to change the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to change\&. 0 = x, 1 = y, 2 = z, 3 = w\&. 
.RE
.PP

.SS "void Vector::Reset (F32 val = \fC0\&.0f\fP)"
Sets all values to input\&. Does not check for _2D before changing z\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value x, y and z will get\&. w is set to 1\&.0f\&. Default value is 0\&.0f\&. 
.RE
.PP

.SS "void KillerMath::Vector::Set (F32 xVal, F32 yVal, F32 zVal)\fC [inline]\fP"
A helper function to allow to quickly set x, y and z to different values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the value for x\&. 
.br
\fIyVal\fP is the vlaue for y\&. 
.br
\fIzVal\fP is the value for z\&. 
.RE
.PP

.SS "F32 Vector::SqrMagnitude (void)"
Returns the squard length of the \fBVector\fP\&. It avoids the cost of the square root function\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

.TH "KillerMath::Vector4" 3 "Sat Jun 1 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Vector4
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Vector4\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector4\fP (void)"
.br
.ti -1c
.RI "\fBVector4\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector4\fP (\fBF32\fP x, \fBF32\fP y)"
.br
.ti -1c
.RI "\fBVector4\fP (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
.br
.ti -1c
.RI "\fBVector4\fP (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z, \fBF32\fP w)"
.br
.ti -1c
.RI "\fBVector4\fP (const \fBVector4\fP &v)"
.br
.ti -1c
.RI "\fBVector4\fP (const \fBPoint\fP &p)"
.br
.ti -1c
.RI "\fB~Vector4\fP (void)"
.br
.ti -1c
.RI "void \fBMake2D\fP (bool state=true)"
.br
.ti -1c
.RI "void \fBMake3D\fP (bool state=false)"
.br
.ti -1c
.RI "bool \fBIs2D\fP (void) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDot\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDot\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "\fBVector4\fP \fBCrossProduct\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "\fBF32\fP \fBMagnitude\fP (void)"
.br
.ti -1c
.RI "\fBF32\fP \fBSqrMagnitude\fP (void)"
.br
.ti -1c
.RI "void \fBNormalize\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (\fBF32\fP val=0\&.0f)"
.br
.ti -1c
.RI "void \fBAddScaledVector4\fP (const \fBVector4\fP &vec, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBF32\fP * \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBSet\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "const \fBF32\fP & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "\fBF32\fP & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator=\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator=\fP (const \fBPoint\fP &point)"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator=\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator+\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator+=\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator+\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator+=\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator+\fP (const \fBPoint\fP &\fBPoint\fP) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator+=\fP (const \fBPoint\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator+\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator+=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator+\fP (shared_ptr< \fBVector4\fP > vec) const"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator\-\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator\-=\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator\-\fP (const \fBVector3\fP &vec) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator\-=\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator\-\fP (const \fBPoint\fP &vec) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator\-=\fP (const \fBPoint\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator\-\fP (void)"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator++\fP (void)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator\-\-\fP (void)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator\-\-\fP (int)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator\-\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator\-=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator*\fP (const \fBVector4\fP vec) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator*=\fP (const \fBVector4\fP vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator*\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator*=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator/\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator/=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBVector4\fP &vec) const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fB_2D\fP"
.br
.RI "Used to decide whether to use 2D or 3D logic in operators\&. "
.ti -1c
.RI "\fBF32\fP \fB_data\fP [4]"
.br
.RI "Array that stores the values for each element\&. "
.in -1c
.SH "Detailed Description"
.PP 
A custom \fBVector4\fP class writen for the Killer Engine\&.
.PP
The \fBVector4\fP is a 4 element 3D \fBVector4\fP\&. The \fBVector4\fP consists of an x, y, z and w component represented by an array of F32 values\&. They are refered as x, y, z and w through through documentation\&. In code, you would have to refered to them as their index in the array (0 - 3)\&. There is an alias set up in the \fBVector4\fP, and enum, that lets you use x, y, z and w to represent the indices natively\&. This is private to the \fBVector4\fP\&.
.PP
The w element is what separates a \fBVector4\fP from a \fBVector4\fP\&. A \fBVector4\fP is meant to represent a direction with a magnitude\&. This has many uses in equations involving direction and distance\&. Because of what this represents, transforming a direction does not make a lot of sense\&. It should be able to be rotated, stretched, shered, pretty much any of the affine trans- formations, but it should not be linearly transformed\&. This is represented by keeping the w component set to 0\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Vector4::Vector4 (void)"
Default construtor\&. Sets all values to 0, and _2D to false\&. W is set to 1\&. 
.SS "Vector4::Vector4 (\fBF32\fP val)\fC [explicit]\fP"
Single input conversion constructor\&. It will set the x, y and z components to the input\&. _2D is false\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP F32: Input value for x, y and z\&. 
.RE
.PP

.SS "Vector4::Vector4 (\fBF32\fP x, \fBF32\fP y)"
Two input constructor\&. Set's x and y accordingly\&. Z is set to 0\&.0f\&. W is set to 1\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.RE
.PP

.SS "Vector4::Vector4 (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
Three input constructor\&. W is set to 1\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.br
\fIz\fP is the value for z\&. 
.RE
.PP

.SS "Vector4::Vector4 (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z, \fBF32\fP w)"
Four input constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.br
\fIz\fP is the value for z\&. 
.br
\fIw\fP is the value for w\&. 
.RE
.PP

.SS "Vector4::Vector4 (const \fBVector4\fP & v)"
Copy Constructor\&. It explicitly copies all data into new \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP is the \fBVector4\fP to copy\&. 
.RE
.PP

.SS "Vector4::Vector4 (const \fBPoint\fP & p)\fC [explicit]\fP"
Copy a \fBPoint\fP into a \fBVector4\fP\&. W is set to 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP will be converted into a \fBVector4\fP\&. 
.RE
.PP

.SS "Vector4::~Vector4 (void)"
Destructor\&. It does not do anything\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Vector4::AddScaledVector4 (const \fBVector4\fP & vec, \fBF32\fP scale)"
Adds a \fBVector4\fP scaled by a value to this \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP that will be added to this one\&. 
.br
\fIscale\fP is the amount the added \fBVector4\fP will be scaled by\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::CrossProduct (const \fBVector4\fP & vec) const"
Performs a Cross or \fBVector4\fP production in the order of this % other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "\fBF32\fP Vector4::Dot (const \fBVector4\fP & vec) const"
Performs a Dot or Scalar product in the order of this * other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "\fBF32\fP Vector4::Dot (const \fBPoint\fP & point) const"
Performs a Dot or Scalar product in the order of this * other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "const \fBF32\fP* KillerMath::Vector4::GetElems (void) const\fC [inline]\fP"
Returns the raw data for the \fBVector4\fP\&. 
.SS "bool KillerMath::Vector4::Is2D (void) const\fC [inline]\fP"
Returns that 2D state of the \fBVector4\fP stored in _2D; 
.SS "\fBF32\fP Vector4::Magnitude (void)"
Returns the length of the \fBVector4\fP\&. Caution, this uses the square root function\&. 
.SS "void KillerMath::Vector4::Make2D (bool state = \fCtrue\fP)\fC [inline]\fP"
Sets the \fBVector4\fP to act like a 2D \fBVector4\fP instead of a 3D \fBVector4\fP by setting _2D to true\&. This means that the z value wont be copied or used in operations\&. 
.SS "void KillerMath::Vector4::Make3D (bool state = \fCfalse\fP)\fC [inline]\fP"
Sets the \fBVector4\fP to act like a 3D \fBVector4\fP instead of a 3D \fBVector4\fP by settings _2D to true\&. This means that the z value will be copied and used in operations\&. 
.SS "void Vector4::Normalize (void)"
Changes the \fBVector4\fP into a unit \fBVector4\fP by converting its magnitude to exaclty 1\&.0\&. This is an expensive operation\&. 
.SS "bool Vector4::operator!= (const \fBVector4\fP & vec) const"
False equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are not equal to all elements of other \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP this \fBVector4\fP will be compared against\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator* (const \fBVector4\fP vec) const"
\fBVector4\fP multiplication\&. This is a componentwise multiplication, scaling one \fBVector4\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP multiplied by the new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator* (\fBF32\fP val) const"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBVector4\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by the new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator*= (const \fBVector4\fP vec)"
\fBVector4\fP multiplication\&. This is a componentwise multiplication, scaling one \fBVector4\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP multiplied by this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator*= (\fBF32\fP val)"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBVector4\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator+ (const \fBVector4\fP & vec) const"
\fBVector4\fP addtion\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP to add into a new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator+ (const \fBVector3\fP & vec) const"
\fBVector3\fP addtion\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP to add into a new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator+ (const \fBPoint\fP & Point) const"
\fBPoint\fP addtion\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBPoint\fP to add into a new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator+ (\fBF32\fP val) const"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into the elements of a new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator+ (shared_ptr< \fBVector4\fP > vec) const"
Shared Pointer addition\&. A helper to allow arithmetic with shared_ptr<Vector4>\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the shared_ptr<Vector4> that is added into each element of a new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP& KillerMath::Vector4::operator++ (void)\fC [inline]\fP"
Prefix, Adds 1 to each element of the \fBVector4\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBVector4\fP KillerMath::Vector4::operator++ (int)\fC [inline]\fP"
Postfix, Adds 1 to each element of the \fBVector4\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBVector4\fP & Vector4::operator+= (const \fBVector4\fP & vec)"
\fBVector4\fP addition equal\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP to add into this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator+= (const \fBVector3\fP & vec)"
\fBVector3\fP addition equal\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP to add into this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator+= (const \fBPoint\fP & vec)"
\fBPoint\fP addition equal\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBPoint\fP to add into this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator+= (\fBF32\fP val)"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into each element of this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator\- (const \fBVector4\fP & vec) const"
\fBVector4\fP subtraction\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP subtracted from the new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator\- (const \fBVector3\fP & vec) const"
\fBVector3\fP subtraction\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP subtracted from the new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator\- (const \fBPoint\fP & vec) const"
\fBPoint\fP subtraction\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBPoint\fP subtracted from the new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP KillerMath::Vector4::operator\- (void)\fC [inline]\fP"
Changes the sign of each element of the \fBVector4\fP\&. If 2D, z is not changed\&. w is also ignored\&. 
.SS "\fBVector4\fP Vector4::operator\- (\fBF32\fP val) const"
Scalar subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from the new \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP& KillerMath::Vector4::operator\-\- (void)\fC [inline]\fP"
Prefix, Subtracts 1 to each element of the \fBVector4\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBVector4\fP KillerMath::Vector4::operator\-\- (int)\fC [inline]\fP"
Postfix, Subtracts 1 to each element of the \fBVector4\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBVector4\fP & Vector4::operator\-= (const \fBVector4\fP & vec)"
\fBVector4\fP subtraction\&. This is done componenetwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the Vector4ed subtractd from this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator\-= (const \fBVector3\fP & vec)"
\fBVector3\fP subtraction\&. This is done componenetwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector3\fP subtracted from this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator\-= (const \fBPoint\fP & vec)"
\fBPoint\fP subtraction\&. This is done componenetwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBPoint\fP subtracted from this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator\-= (\fBF32\fP val)"
Sclara subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from each element of this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP Vector4::operator/ (\fBF32\fP val) const"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar the new \fBVector4\fP is divided by\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator/= (\fBF32\fP val)"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar this \fBVector4\fP is divided by\&. 
.RE
.PP

.SS "bool Vector4::operator< (const \fBVector4\fP & vec) const"
Less than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than all elements of the other \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP this \fBVector4\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector4::operator<= (const \fBVector4\fP & vec) const"
Less than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than or equal to all elements of the other \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP this \fBVector4\fP will be compared against\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator= (const \fBVector4\fP & vec)"
Copy assignment from \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP to copy into this \fBVector4\fP\&. 
.RE
.PP

.SS "\fBVector4\fP & Vector4::operator= (\fBF32\fP val)"
Copy assignment from scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value all elements will be set to\&. w is not affect\&. 2D check is done before z is changed\&. 
.RE
.PP

.SS "bool Vector4::operator== (const \fBVector4\fP & vec) const"
Equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are equal to all elements of other \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP this \fBVector4\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector4::operator> (const \fBVector4\fP & vec) const"
Greater than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than all elements of the other \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP this \fBVector4\fP will be compared against\&. 
.RE
.PP

.SS "bool Vector4::operator>= (const \fBVector4\fP & vec) const"
Greater than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than or equal to all elements of the other \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the \fBVector4\fP this \fBVector4\fP will be compared against\&. 
.RE
.PP

.SS "const \fBF32\fP& KillerMath::Vector4::operator[] (int i) const\fC [inline]\fP"
Allows you to index into the \fBVector4\fP to read the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to read\&. 0 = x, 1 = y, 2 = z, 3 = w\&. 
.RE
.PP

.SS "\fBF32\fP& KillerMath::Vector4::operator[] (int i)\fC [inline]\fP"
Allows you to index into the \fBVector4\fP to change the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to change\&. 0 = x, 1 = y, 2 = z, 3 = w\&. 
.RE
.PP

.SS "void Vector4::Reset (\fBF32\fP val = \fC0\&.0f\fP)"
Sets all values to input\&. Does not check for _2D before changing z\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value x, y and z will get\&. w is set to 1\&.0f\&. Default value is 0\&.0f\&. 
.RE
.PP

.SS "void KillerMath::Vector4::Set (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [inline]\fP"
A helper function to allow to quickly set x, y and z to different values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the value for x\&. 
.br
\fIyVal\fP is the vlaue for y\&. 
.br
\fIzVal\fP is the value for z\&. 
.RE
.PP

.SS "\fBF32\fP Vector4::SqrMagnitude (void)"
Returns the squard length of the \fBVector4\fP\&. It avoids the cost of the square root function\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

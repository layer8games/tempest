.TH "KillerMath::Point" 3 "Mon Feb 25 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Point
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Point\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPoint\fP (void)"
.br
.ti -1c
.RI "\fBPoint\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBPoint\fP (\fBF32\fP x, \fBF32\fP y)"
.br
.ti -1c
.RI "\fBPoint\fP (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
.br
.ti -1c
.RI "\fBPoint\fP (const \fBPoint\fP &p)"
.br
.ti -1c
.RI "\fB~Point\fP (void)"
.br
.ti -1c
.RI "void \fBMake2D\fP (void)"
.br
.ti -1c
.RI "void \fBMake3D\fP (void)"
.br
.ti -1c
.RI "bool \fBIs2D\fP (void) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDot\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "\fBPoint\fP \fBCrossProduct\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "\fBF32\fP \fBMagnitude\fP (void)"
.br
.ti -1c
.RI "\fBF32\fP \fBSqrMagnitude\fP (void)"
.br
.ti -1c
.RI "void \fBNormalize\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (\fBF32\fP val=0\&.0f)"
.br
.ti -1c
.RI "void \fBAddScaledPoint\fP (const \fBPoint\fP &point, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBF32\fP * \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBSet\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "const \fBF32\fP & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "\fBF32\fP & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator=\fP (const \fBPoint\fP &point)"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator+\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator+=\fP (const \fBPoint\fP &point)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator+\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator+=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator+\fP (shared_ptr< \fBPoint\fP > point) const"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator\-\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator\-=\fP (const \fBPoint\fP &point)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator\-\fP (void)"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator++\fP (void)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator\-\-\fP (void)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator\-\-\fP (int)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator\-\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator\-=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator*\fP (const \fBPoint\fP point) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator*=\fP (const \fBPoint\fP point)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator*\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator*=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator/\fP (\fBF32\fP val) const"
.br
.ti -1c
.RI "\fBPoint\fP & \fBoperator/=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBPoint\fP &point) const"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBx\fP = 0, \fBy\fP = 1, \fBz\fP = 2, \fBw\fP = 3 }"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fB_2D\fP"
.br
.RI "Used to decide whether to use 2D or 3D logic in operators\&. "
.ti -1c
.RI "\fBF32\fP \fB_data\fP [4]"
.br
.RI "Array that stores the values for each element\&. "
.in -1c
.SH "Detailed Description"
.PP 
A custom \fBPoint\fP class writen for the Killer Engine\&.
.PP
The \fBPoint\fP is a 4 element 3D \fBPoint\fP\&. The \fBPoint\fP consists of an x, y, z and w component represented by an array of F32 values\&. They are refered as x, y, z and w through through documentation\&. In code, you would have to refered to them as their index in the array (0 - 3)\&. There is an alias set up in the \fBPoint\fP, and enum, that lets you use x, y, z and w to represent the indices natively\&. This is private to the \fBPoint\fP\&.
.PP
The w element is what separates a \fBVector4\fP from a \fBPoint\fP\&. A \fBPoint\fP is meant to represent a point in space\&. This can also be thought of as a displayment from the origin of the planes\&. This is expressed mathematically by always having the w component be 1, which allows the \fBPoint\fP to be transformed by a Matrix with transformation values added\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum\fC [private]\fP"
Alias set up to allow a refernce to each element that is more human readable in the code\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Point::Point (void)"
Default construtor\&. Sets all values to 0, and _2D to false\&. 
.SS "Point::Point (\fBF32\fP val)\fC [explicit]\fP"
Single input conversion constructor\&. It will set the x, y and z components to the input\&. _2D is false\&. W is set to 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP F32: Input value for x, y and z\&. 
.RE
.PP

.SS "Point::Point (\fBF32\fP x, \fBF32\fP y)"
Two input constructor\&. Set's x and y accordingly\&. Z is set to 0\&.0f\&. W is set to 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.RE
.PP

.SS "Point::Point (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
Three input constructor\&. W is set to 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for x\&. 
.br
\fIy\fP is the value for y\&. 
.br
\fIz\fP is the value for z\&. 
.RE
.PP

.SS "Point::Point (const \fBPoint\fP & p)"
Copy Constructor\&. It explicitly copies all data into new \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP is the \fBPoint\fP to copy\&. 
.RE
.PP

.SS "Point::~Point (void)"
Destructor\&. It does not do anything\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Point::AddScaledPoint (const \fBPoint\fP & point, \fBF32\fP scale)"
Adds a \fBPoint\fP scaled by a value to this \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP that will be added to this one\&. 
.br
\fIscale\fP is the amount the added \fBPoint\fP will be scaled by\&. 
.RE
.PP

.SS "\fBPoint\fP Point::CrossProduct (const \fBPoint\fP & point) const"
Performs a Cross or \fBPoint\fP production in the order of this % other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "\fBF32\fP Point::Dot (const \fBPoint\fP & point) const"
Performs a Dot or Scalar product in the order of this * other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the left hand argument in the operation\&. 
.RE
.PP

.SS "const \fBF32\fP* KillerMath::Point::GetElems (void) const\fC [inline]\fP"
Returns the raw data for the \fBPoint\fP\&. 
.SS "bool KillerMath::Point::Is2D (void) const\fC [inline]\fP"
Returns that 2D state of the \fBPoint\fP stored in _2D; 
.SS "\fBF32\fP Point::Magnitude (void)"
Returns the length of the \fBPoint\fP\&. Caution, this uses the square root function\&. 
.SS "void KillerMath::Point::Make2D (void)\fC [inline]\fP"
Sets the \fBPoint\fP to act like a 2D \fBPoint\fP instead of a 3D \fBPoint\fP by setting _2D to true\&. This means that the z value wont be copied or used in operations\&. 
.SS "void KillerMath::Point::Make3D (void)\fC [inline]\fP"
Sets the \fBPoint\fP to act like a 3D \fBPoint\fP instead of a 3D \fBPoint\fP by settings _2D to true\&. This means that the z value will be copied and used in operations\&. 
.SS "void Point::Normalize (void)"
Changes the \fBPoint\fP into a unit \fBPoint\fP by converting its magnitude to exaclty 1\&.0\&. This is an expensive operation\&. 
.SS "bool Point::operator!= (const \fBPoint\fP & point) const"
False equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are not equal to all elements of other \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP this \fBPoint\fP will be compared against\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator* (const \fBPoint\fP point) const"
\fBPoint\fP multiplication\&. This is a componentwise multiplication, scaling one \fBPoint\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP multiplied by the new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator* (\fBF32\fP val) const"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBPoint\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by the new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator*= (const \fBPoint\fP point)"
\fBPoint\fP multiplication\&. This is a componentwise multiplication, scaling one \fBPoint\fP by another\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP multiplied by this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator*= (\fBF32\fP val)"
Scalar multiplication\&. This is a componentwise multiplication, scaling the \fBPoint\fP by the scalar\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar multiplied by this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator+ (const \fBPoint\fP & point) const"
\fBPoint\fP addtion\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP to add into a new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator+ (\fBF32\fP val) const"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into the elements of a new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator+ (shared_ptr< \fBPoint\fP > point) const"
Shared Pointer addition\&. A helper to allow arithmetic with shared_ptr<Point>\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the shared_ptr<Point> that is added into each element of a new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP& KillerMath::Point::operator++ (void)\fC [inline]\fP"
Prefix, Adds 1 to each element of the \fBPoint\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBPoint\fP KillerMath::Point::operator++ (int)\fC [inline]\fP"
Postfix, Adds 1 to each element of the \fBPoint\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBPoint\fP & Point::operator+= (const \fBPoint\fP & point)"
\fBPoint\fP addition equal\&. This is done componentwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP to add into this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator+= (\fBF32\fP val)"
Scalar addition\&. Each value is added into\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is added into each element of this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator\- (const \fBPoint\fP & point) const"
\fBPoint\fP subtraction\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP subtracted from the new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP KillerMath::Point::operator\- (void)\fC [inline]\fP"
Changes the sign of each element of the \fBPoint\fP\&. If 2D, z is not changed\&. w is also ignored\&. 
.SS "\fBPoint\fP Point::operator\- (\fBF32\fP val) const"
Scalar subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from the new \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP& KillerMath::Point::operator\-\- (void)\fC [inline]\fP"
Prefix, Subtracts 1 to each element of the \fBPoint\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBPoint\fP KillerMath::Point::operator\-\- (int)\fC [inline]\fP"
Postfix, Subtracts 1 to each element of the \fBPoint\fP\&. If 2D, z is ignored\&. w is always ignored\&. 
.SS "\fBPoint\fP & Point::operator\-= (const \fBPoint\fP & point)"
\fBPoint\fP subtraction\&. This is done componenetwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the Pointed subtractd from this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator\-= (\fBF32\fP val)"
Sclara subtraction\&. 2D check is done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar subtracted from each element of this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP Point::operator/ (\fBF32\fP val) const"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar the new \fBPoint\fP is divided by\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator/= (\fBF32\fP val)"
Scalar division\&. This is done componentwise\&. 2D check done before z is changed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the scalar this \fBPoint\fP is divided by\&. 
.RE
.PP

.SS "bool Point::operator< (const \fBPoint\fP & point) const"
Less than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than all elements of the other \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP this \fBPoint\fP will be compared against\&. 
.RE
.PP

.SS "bool Point::operator<= (const \fBPoint\fP & point) const"
Less than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are less than or equal to all elements of the other \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP this \fBPoint\fP will be compared against\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator= (const \fBPoint\fP & point)"
Copy assignment from \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP to copy into this \fBPoint\fP\&. 
.RE
.PP

.SS "\fBPoint\fP & Point::operator= (\fBF32\fP val)"
Copy assignment from scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value all elements will be set to\&. w is not affect\&. 2D check is done before z is changed\&. 
.RE
.PP

.SS "bool Point::operator== (const \fBPoint\fP & point) const"
Equality comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are equal to all elements of other \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP this \fBPoint\fP will be compared against\&. 
.RE
.PP

.SS "bool Point::operator> (const \fBPoint\fP & point) const"
Greater than comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than all elements of the other \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP this \fBPoint\fP will be compared against\&. 
.RE
.PP

.SS "bool Point::operator>= (const \fBPoint\fP & point) const"
Greater than or equal to comparison\&. 2D is used as an early out\&. 2D is also checked before z is compared\&. Only true if all elements of this are greater than or equal to all elements of the other \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the \fBPoint\fP this \fBPoint\fP will be compared against\&. 
.RE
.PP

.SS "const \fBF32\fP& KillerMath::Point::operator[] (int i) const\fC [inline]\fP"
Allows you to index into the \fBPoint\fP to read the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to read\&. 0 = x, 1 = y, 2 = z, 3 = w\&. 
.RE
.PP

.SS "\fBF32\fP& KillerMath::Point::operator[] (int i)\fC [inline]\fP"
Allows you to index into the \fBPoint\fP to change the value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index you wish to change\&. 0 = x, 1 = y, 2 = z, 3 = w\&. 
.RE
.PP

.SS "void Point::Reset (\fBF32\fP val = \fC0\&.0f\fP)"
Sets all values to input\&. Does not check for _2D before changing z\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value x, y and z will get\&. w is set to 1\&.0f\&. Default value is 0\&.0f\&. 
.RE
.PP

.SS "void KillerMath::Point::Set (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [inline]\fP"
A helper function to allow to quickly set x, y and z to different values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the value for x\&. 
.br
\fIyVal\fP is the vlaue for y\&. 
.br
\fIzVal\fP is the value for z\&. 
.RE
.PP

.SS "\fBF32\fP Point::SqrMagnitude (void)"
Returns the squard length of the \fBPoint\fP\&. It avoids the cost of the square root function\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

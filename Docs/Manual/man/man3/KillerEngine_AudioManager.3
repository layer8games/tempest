.TH "KillerEngine::AudioManager" 3 "Tue Jun 4 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerEngine::AudioManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <AudioManager\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~AudioManager\fP (void)"
.br
.ti -1c
.RI "void \fBAddClip\fP (\fBU32\fP id, shared_ptr< \fBAudioClip\fP > clip)"
.br
.ti -1c
.RI "void \fBLoadClip\fP (\fBU32\fP id, string filepath)"
.br
.ti -1c
.RI "void \fBRemoveClip\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBAddSource\fP (\fBU32\fP id, shared_ptr< \fBAudioSource\fP > source)"
.br
.ti -1c
.RI "void \fBLoadSource\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBRemoveSource\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBPlaySource\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBStopSource\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBPauseSource\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBRestartSource\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "void \fBAddClipToSource\fP (\fBU32\fP clipID, \fBU32\fP sourceID)"
.br
.ti -1c
.RI "string \fBGetALCerror\fP (ALCenum error)"
.br
.ti -1c
.RI "void \fBSetListener\fP (void)"
.br
.ti -1c
.RI "void \fBSetListener\fP (shared_ptr< \fBAudioListener\fP > listener)"
.br
.ti -1c
.RI "shared_ptr< \fBAudioListener\fP > \fBGetListener\fP (void)"
.br
.ti -1c
.RI "shared_ptr< \fBAudioClip\fP > \fBGetClip\fP (\fBU32\fP id)"
.br
.ti -1c
.RI "shared_ptr< \fBAudioSource\fP > \fBGetSource\fP (\fBU32\fP id)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static shared_ptr< \fBAudioManager\fP > \fBInstance\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBAudioManager\fP (void)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "ALCdevice * \fB_device\fP"
.br
.RI "OpenAL device handle\&. "
.ti -1c
.RI "ALCcontext * \fB_context\fP"
.br
.RI "OpenAL context handle\&. "
.ti -1c
.RI "shared_ptr< \fBAudioListener\fP > \fB_listener\fP"
.br
.RI "Pointer to the listener for this context\&. "
.ti -1c
.RI "std::map< \fBU32\fP, shared_ptr< \fBAudioClip\fP > > \fB_clips\fP"
.br
.RI "Collection of registered clips\&. "
.ti -1c
.RI "std::map< \fBU32\fP, shared_ptr< \fBAudioSource\fP > > \fB_sources\fP"
.br
.RI "Collection of registered sources\&. "
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static shared_ptr< \fBAudioManager\fP > \fB_instance\fP = nullptr"
.br
.RI "Global instance of the manager\&. Singleton pattern\&. "
.in -1c
.SH "Detailed Description"
.PP 
Global manager to hold cached AudioSources and AudioClips\&. It can start and stop cached sources, and assign clips to sources that have been registered with it\&. It does this using a map\&. ID's are U32 value\&. The values are pointers\&. It also holds the single context and device for the game\&. Later, there may be a need to have multiple contextes\&. If this happens, this will need to be abstracted out to its own class\&. The manager follows the same singleton pattern as other managers in the KillerEngine\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AudioManager::~AudioManager (void)"
Sets the \fBAudioListener\fP pointer to nullptr, clears out all AudioClips and AudioSources, and deletes the OpenAL context and device\&. 
.SS "AudioManager::AudioManager (void)\fC [protected]\fP"
Created the OpenAL device handle and context handle\&. Also contains commented out code that would return a list of available devices, if it is ever desired to allow a user to select which device they would like the audio to play on\&. 
.SH "Member Function Documentation"
.PP 
.SS "void AudioManager::AddClip (\fBU32\fP id, shared_ptr< \fBAudioClip\fP > clip)"
Registers an \fBAudioClip\fP with an ID to the manager\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID for this clip\&. 
.br
\fIclip\fP is a pointer to the clip to register with the manager\&. 
.RE
.PP

.SS "void AudioManager::AddClipToSource (\fBU32\fP clipID, \fBU32\fP sourceID)"
Assigns a registered \fBAudioClip\fP to a registered \fBAudioSource\fP in the manager\&. This is a helper function for better abstract operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fIclipID\fP is the ID of the clip that is assigned\&. 
.br
\fIsourceID\fP si the ID of the source that will be assigned the clip\&. 
.RE
.PP

.SS "void AudioManager::AddSource (\fBU32\fP id, shared_ptr< \fBAudioSource\fP > source)"
Registers an \fBAudioSource\fP with ID to the manager\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID for this source\&. 
.br
\fIsource\fP is a pointer to the source to register with the manager\&. 
.RE
.PP

.SS "string AudioManager::GetALCerror (ALCenum error)"
Helper function that returns a string version of an OpenAL error\&. Used any time that you need to convert and OpenAL error code into a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIerror\fP is the OpenAL error code returned by alGetError()\&. 
.RE
.PP

.SS "shared_ptr< \fBAudioClip\fP > AudioManager::GetClip (\fBU32\fP id)"
Returns the registered \fBAudioClip\fP with the given ID\&. If no clip is found with the ID, a nullptr is returned\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID for the desired clip\&. 
.RE
.PP

.SS "shared_ptr<\fBAudioListener\fP> KillerEngine::AudioManager::GetListener (void)\fC [inline]\fP"
Returns a pointer to the current listener\&. Note, this is NOT const\&. This was done as a pattern experiment\&. Instead of writting functions for all the different operations you may want to perform on a listener, it is returned as writable so that you can call any functions that you need to\&. 
.SS "shared_ptr< \fBAudioSource\fP > AudioManager::GetSource (\fBU32\fP id)"
Returns the registered \fBAudioSource\fP wit h the given ID\&. If no source is found with the ID, a nullptr is returned\&. \\ 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID for the desired source\&. 
.RE
.PP

.SS "shared_ptr< \fBAudioManager\fP > AudioManager::Instance (void)\fC [static]\fP"
Singleton pattern\&. Returns a pointer to the global instance of the manager\&. 
.SS "void AudioManager::LoadClip (\fBU32\fP id, string filepath)"
Experimental function\&. It needs to be tested if this created memory issues\&. It created a new pointer to an \fBAudioClip\fP, and calls \fBAudioClip::LoadWAV\fP, then registers this with the manager\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID used to register the clip after creation\&. 
.br
\fIfilepath\fP is the path to the audio file used by the clip\&. 
.RE
.PP

.SS "void AudioManager::LoadSource (\fBU32\fP id)"
Experimental function\&. This created a new \fBAudioSource\fP pointer that is then registered with the manager for later use\&. It needs to be test if this creates any memory issues\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID used to register the new source 
.RE
.PP

.SS "void AudioManager::PauseSource (\fBU32\fP id)"
Calls \fBAudioSource::Pause\fP on the source with the given ID\&. No check is done in the manager to make sure this works, it relies on the source to do any checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID of the source to Pause\&. 
.RE
.PP

.SS "void AudioManager::PlaySource (\fBU32\fP id)"
Calls \fBAudioSource::Play\fP on the source with the given ID\&. No check is done in the manager to make sure this works, it relies on the source to do any checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID of the source to play\&. 
.RE
.PP

.SS "void AudioManager::RemoveClip (\fBU32\fP id)"
Unregisters an \fBAudioClip\fP from the manager\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID for the clip that is to be unregistered\&. 
.RE
.PP

.SS "void AudioManager::RemoveSource (\fBU32\fP id)"
Unregisters an \fBAudioSource\fP from the manager\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID of the source to unregister from the manager\&. 
.RE
.PP

.SS "void AudioManager::RestartSource (\fBU32\fP id)"
Calls \fBAudioSource::Restart\fP on the source with the given ID\&. No check is done in the manager to make sure this works, it relies on the source to do any checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID of the source to Restart\&. 
.RE
.PP

.SS "void KillerEngine::AudioManager::SetListener (void)\fC [inline]\fP"
Experimental function\&. Sets the listener to a new pointer\&. This needs to be tested to see if it causes any memory issues\&. 
.SS "void KillerEngine::AudioManager::SetListener (shared_ptr< \fBAudioListener\fP > listener)\fC [inline]\fP"
Sets the listener to the given pointer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP is the new pointer that will be used\&. 
.RE
.PP

.SS "void AudioManager::StopSource (\fBU32\fP id)"
Calls \fBAudioSource::Stop\fP on the source with the given ID\&. No check is done in the manager to make sure this works, it relies on the source to do any checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP is the unique ID of the source to Stop\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

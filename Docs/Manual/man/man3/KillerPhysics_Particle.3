.TH "KillerPhysics::Particle" 3 "Thu Mar 7 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerPhysics::Particle
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Particle\&.h>\fP
.PP
Inherits \fBKillerEngine::GameObject\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBParticle\fP (void)"
.br
.ti -1c
.RI "\fBParticle\fP (const \fBParticle\fP *particle)"
.br
.ti -1c
.RI "\fBParticle\fP (const \fBParticle\fP &particle)"
.br
.ti -1c
.RI "virtual \fB~Particle\fP (void)"
.br
.ti -1c
.RI "virtual void \fBv_Update\fP ()"
.br
.ti -1c
.RI "void \fBIntegrate\fP (void)"
.br
.ti -1c
.RI "void \fBClearAccumulator\fP (void)"
.br
.ti -1c
.RI "void \fBAddForce\fP (const \fBKM::Vector4\fP force)"
.br
.ti -1c
.RI "const \fBKM::Vector4\fP & \fBGetVelocity\fP (void) const"
.br
.ti -1c
.RI "void \fBSetVelocity\fP (const \fBKM::Vector4\fP &vel)"
.br
.ti -1c
.RI "void \fBSetVelocity\fP (\fBF32\fP x, \fBF32\fP y)"
.br
.ti -1c
.RI "void \fBSetVelocity\fP (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
.br
.ti -1c
.RI "void \fBAddScaledVelocity\fP (const \fBKM::Vector4\fP &vec, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBKM::Vector4\fP & \fBGetAcceleration\fP (void) const"
.br
.ti -1c
.RI "void \fBSetAcceleration\fP (const \fBKM::Vector4\fP &acc)"
.br
.ti -1c
.RI "void \fBSetAcceleration\fP (\fBF32\fP x, \fBF32\fP y)"
.br
.ti -1c
.RI "void \fBSetAcceleration\fP (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)"
.br
.ti -1c
.RI "void \fBAddScaledAcceleration\fP (const \fBKM::Vector4\fP &acc, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBKM::Vector4\fP & \fBGetForces\fP (void) const"
.br
.ti -1c
.RI "const \fBKM::Vector4\fP & \fBGetGravityForce\fP (void) const"
.br
.ti -1c
.RI "void \fBSetGravityForce\fP (const \fBKM::Vector4\fP &grav)"
.br
.ti -1c
.RI "const \fBreal\fP \fBGetInverseMass\fP (void) const"
.br
.ti -1c
.RI "void \fBSetInverseMass\fP (\fBreal\fP inverseMass)"
.br
.ti -1c
.RI "bool \fBHasFiniteMass\fP (void)"
.br
.ti -1c
.RI "const \fBreal\fP \fBGetMass\fP (void)"
.br
.ti -1c
.RI "void \fBSetMass\fP (\fBreal\fP mass)"
.br
.ti -1c
.RI "const \fBreal\fP \fBGetDamping\fP (void) const"
.br
.ti -1c
.RI "void \fBSetDamping\fP (\fBreal\fP damp)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBKM::Vector4\fP \fB_velocity\fP"
.br
.RI "Represents the rate of change, otherwise known as the first differential of the position\&. "
.ti -1c
.RI "\fBKM::Vector4\fP \fB_acceleration\fP"
.br
.RI "Reprsent the rate of change of the velocity, otherwise known as the second differential of the position\&. "
.ti -1c
.RI "\fBKM::Vector4\fP \fB_forceAccum\fP"
.br
.RI "Using D'Lambert's principal, this reprsents the combined forces that will as on this \fBParticle\fP for exactly 1 frame\&. "
.ti -1c
.RI "\fBKM::Vector4\fP \fB_gravityForce\fP"
.br
.RI "An optimization, gravity does not have to be treated like other forces, it can permanately be cached\&. "
.ti -1c
.RI "\fBreal\fP \fB_inverseMass\fP"
.br
.RI "The inverse mass of the object, written like 1/mass\&. This is an optimization to avoid uneeded operations\&. "
.ti -1c
.RI "\fBreal\fP \fB_damping\fP"
.br
.RI "Damping is a substitute for friction\&. It represents the rate of acceleration decay\&. 0\&.0f means heavy friction, close to 1 means almost none\&. Do not set to 1\&. A good value for no decay is 0\&.999f\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBParticle\fP class reprsents a point mass\&. This means that we pretend that it has no area, that it is a single point in space, but that it has a mass\&. It can be acted on by forces, and most of this magic happens in the Integrate\&.
.PP
Most of the math and ideas were taken from Game Physics Programming by Ian Millington, but have been tweeked by me as I have experiemented with what works in the framework of the KillerEngine\&.
.PP
It inherits from the GameObject, but it is not an abstract class itself\&. It can be inherited from, but this should be done sparingly\&. I attempted to make this a class that would use componsition to work, but it needed to have direct access to the position of GameObject, while the GameObject can handle all of the rendering logic\&. It was was simplier to go with this inheritance schema\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Particle::Particle (void)"
Default Constructor\&. All data values are set to 0, except for _inverseMass, which is set to 1, and _damping, which is set to 0\&.999f\&. 
.SS "Particle::Particle (const \fBParticle\fP * particle)"
Pointer Copy Constructor\&. This is here because of some errors that were being thrown at one point\&. It is a full copy\&. 
.SS "Particle::Particle (const \fBParticle\fP & particle)"
Reference Copy Constructor\&. This was the perfered method of copy, I don't even know if this will be used any more\&. 
.SS "Particle::~Particle (void)\fC [virtual]\fP"
Default destructor\&. Virtual because this class is a child of the GameObject\&. It performs no function\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Particle::AddForce (const \fBKM::Vector4\fP force)"
Adds a force that will act upon this \fBParticle\fP\&. This is done by adding the combined forces into the acceleration of the \fBParticle\fP\&. 
.SS "void KillerPhysics::Particle::AddScaledAcceleration (const \fBKM::Vector4\fP & acc, \fBF32\fP scale)\fC [inline]\fP"
Directly add a scaled Vector4y into the current acceleration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the Vector4 to be added\&. 
.br
\fIscale\fP is the F32 that vec will be scaled by before it is added into the acceleration\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::AddScaledVelocity (const \fBKM::Vector4\fP & vec, \fBF32\fP scale)\fC [inline]\fP"
Directly add a scaled Vector4y into the current velocity\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the Vector4 to be added\&. 
.br
\fIscale\fP is the F32 that vec will be scaled by before it is added into the velocity\&. 
.RE
.PP

.SS "void Particle::ClearAccumulator (void)"
Removed all forces that have been applied to the \fBParticle\fP this frame\&. 
.SS "const \fBKM::Vector4\fP& KillerPhysics::Particle::GetAcceleration (void) const\fC [inline]\fP"
Returns the current acceleration of the particle\&. 
.SS "const \fBreal\fP KillerPhysics::Particle::GetDamping (void) const\fC [inline]\fP"
Returns the current damping for the \fBParticle\fP\&. 
.SS "const \fBKM::Vector4\fP& KillerPhysics::Particle::GetForces (void) const\fC [inline]\fP"
Returns the total amount of all the forces applied to this particle for this frame added together\&. 
.SS "const \fBKM::Vector4\fP& KillerPhysics::Particle::GetGravityForce (void) const\fC [inline]\fP"
Returns the value cached to represent the force of gravity on this \fBParticle\fP\&. 
.SS "const \fBreal\fP KillerPhysics::Particle::GetInverseMass (void) const\fC [inline]\fP"
Returns the Inverse Mass of this \fBParticle\fP\&. 
.SS "const \fBreal\fP Particle::GetMass (void)"
Returns the actual Mass of the \fBParticle\fP object\&. 
.SS "const \fBKM::Vector4\fP& KillerPhysics::Particle::GetVelocity (void) const\fC [inline]\fP"
Returns the current velocity of the \fBParticle\fP\&. 
.SS "bool KillerPhysics::Particle::HasFiniteMass (void)\fC [inline]\fP"
As a convention, if the inverse mass is less than 0\&.0f, then the mass of this \fBParticle\fP is thought of as being infinate, that is, it is an immovable object\&. This returns the current state of the mass relation to this logic\&. 
.SS "void Particle::Integrate (void)"
Integrate is where the physical poperties of a point mass are simulated\&. An algorithm is used to update the velocity based off the acceleration, and the position based off the velocity\&. Forces that are applied to this \fBParticle\fP are taken into account for this update\&. All forces are cleared at the end of the integration step\&. 
.SS "void KillerPhysics::Particle::SetAcceleration (const \fBKM::Vector4\fP & acc)\fC [inline]\fP"
Directly set the acceleration of the \fBParticle\fP without regards to physics or the current value of the acceleration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIacc\fP is the new value of the acceleration\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetAcceleration (\fBF32\fP x, \fBF32\fP y)\fC [inline]\fP"
Directly set the acceleration of the \fBParticle\fP without regards to physics or the current value of the acceleration\&. The z value is not affected\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for the x element of the acceleration\&. 
.br
\fIy\fP is the value for the y element of the acceleration\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetAcceleration (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)\fC [inline]\fP"
Directly set the acceleration of the \fBParticle\fP without regards to physics or the current value of the acceleration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for the x element of the acceleration\&. 
.br
\fIy\fP is the value for the y element of the acceleration\&. 
.br
\fIz\fP is the value for teh z element of the acceleration\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetDamping (\fBreal\fP damp)\fC [inline]\fP"
Sets the damping value for the \fBParticle\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdamp\fP is the new value for damping\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetGravityForce (const \fBKM::Vector4\fP & grav)\fC [inline]\fP"
Sets the cached value that represents the force of gravity on this \fBParticle\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgrav\fP is the value that the gravity force will be set to\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetInverseMass (\fBreal\fP inverseMass)\fC [inline]\fP"
Sets the Inverse Mass of this \fBParticle\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinverseMass\fP is the new value for the inverse mass\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetMass (\fBreal\fP mass)\fC [inline]\fP"
Sets the actual Mass of the \fBParticle\fP object\&. Because Mass is stored as the inverse, that is 1/mass, this involves some math to set up the inverse\&. 
.PP
\fBParameters:\fP
.RS 4
\fImass\fP is the value that will be transformed into the inverse mass\&. Cannot be set to 0\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetVelocity (const \fBKM::Vector4\fP & vel)\fC [inline]\fP"
Directly sets the velocity of the \fBParticle\fP, ignoring acceleration and physics\&. This can be viewed as an impulse, but permanent\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvel\fP is the value set for the velocity\&. Disregards what the velocity was\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetVelocity (\fBF32\fP x, \fBF32\fP y)\fC [inline]\fP"
Directly sets the velocity of the \fBParticle\fP, ignoring acceleration and physics\&. This can be viewed as an impulse, but permanent\&. Does not change the z value of the velocity\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for the x part of the velocity\&. 
.br
\fIy\fP is the value for the y part of the velocity\&. 
.RE
.PP

.SS "void KillerPhysics::Particle::SetVelocity (\fBF32\fP x, \fBF32\fP y, \fBF32\fP z)\fC [inline]\fP"
Directly sets the velocity of the \fBParticle\fP, ignoring acceleration and physics\&. This can be viewed as an impulse, but permanent\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value for the x part of the velocity\&. 
.br
\fIy\fP is the value for the y part of the velocity\&.  z is the value for the z part of the velocity\&. 
.RE
.PP

.SS "void Particle::v_Update (void)\fC [virtual]\fP"
v_Update is a virtual function defined in the GameObject::v_Update()\&. This is an empty function (=0), so it must be defined in order to be compiled\&. It is re-declared as virtual so that any children of the \fBParticle\fP can choose to implement it\&. The \fBParticle\fP version is empty\&. 
.PP
Implements \fBKillerEngine::GameObject\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

.TH "KillerMath::Matrix4< T >" 3 "Tue Jun 4 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Matrix4< T >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Matrix4\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMatrix4\fP (void)"
.br
.ti -1c
.RI "\fBMatrix4\fP (const \fBVector4\fP &x, const \fBVector4\fP &y, const \fBVector4\fP &z)"
.br
.ti -1c
.RI "\fBMatrix4\fP (const \fBVector4\fP &x, const \fBVector4\fP &y, const \fBVector4\fP &z, const \fBVector4\fP &w)"
.br
.ti -1c
.RI "\fBMatrix4\fP (const \fBF32\fP val)"
.br
.ti -1c
.RI "\fBMatrix4\fP (\fBF32\fP m00, \fBF32\fP m01, \fBF32\fP m02, \fBF32\fP m03, \fBF32\fP m10, \fBF32\fP m11, \fBF32\fP m12, \fBF32\fP m13, \fBF32\fP m20, \fBF32\fP m21, \fBF32\fP m22, \fBF32\fP m23, \fBF32\fP m30, \fBF32\fP m31, \fBF32\fP m32, \fBF32\fP m33)"
.br
.ti -1c
.RI "\fBMatrix4\fP (const \fBMatrix4\fP &M)"
.br
.ti -1c
.RI "const std::vector< \fBF32\fP > \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBMakeOrthographic\fP (\fBF32\fP left, \fBF32\fP right, \fBF32\fP bottom, \fBF32\fP top, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
.br
.ti -1c
.RI "void \fBMakePerspective\fP (\fBF32\fP fieldOfView, \fBF32\fP aspectRatio, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
.br
.ti -1c
.RI "void \fBSetTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetTranslate\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "void \fBAddTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBAddTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddTranslate\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "\fBVector4\fP \fBTransformInverse\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "void \fBAddScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBAddScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScale\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "void \fBSetRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddRotation\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (const \fBQuaternion\fP &q)"
.br
.ti -1c
.RI "void \fBSetOrientationAndPosition\fP (const \fBQuaternion\fP &q, const \fBVector4\fP &v)"
.br
.ti -1c
.RI "void \fBSetOrientationAndPosition\fP (const \fBQuaternion\fP &q, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "void \fBSetInverse\fP (void)"
.br
.ti -1c
.RI "void \fBSetAsInverse\fP (const \fBMatrix4\fP &mat)"
.br
.ti -1c
.RI "\fBMatrix4\fP \fBGetInverse\fP (void) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDeterminate\fP (void) const"
.br
.ti -1c
.RI "void \fBMakeIdentity\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (\fBF32\fP val=0\&.0f)"
.br
.ti -1c
.RI "void \fBTranspose\fP (void)"
.br
.ti -1c
.RI "void \fBComponentMulti\fP (const \fBMatrix4\fP &M)"
.br
.ti -1c
.RI "\fBMatrix4\fP \fBTransform3x3\fP (const \fBMatrix4\fP &mat) const"
.br
.ti -1c
.RI "\fBVector4\fP \fBTransform3x3\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "void \fBSetLookAt\fP (const \fBVector4\fP &cameraPos, const \fBVector4\fP &target, const \fBVector4\fP &up)"
.br
.ti -1c
.RI "void \fBSetFPSView\fP (const \fBVector4\fP &cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)"
.br
.ti -1c
.RI "const \fBVector4\fP & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "\fBVector4\fP & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBMatrix4\fP & \fBoperator=\fP (const \fBMatrix4\fP &mat)"
.br
.ti -1c
.RI "\fBMatrix4\fP \fBoperator*\fP (const \fBMatrix4\fP &mat) const"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator*\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "\fBPoint\fP \fBoperator*\fP (const \fBPoint\fP &point) const"
.br
.ti -1c
.RI "\fBMatrix4\fP & \fBoperator/=\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "\fBMatrix4\fP (T val)"
.br
.ti -1c
.RI "\fBMatrix4\fP (const T mSrc[16])"
.br
.ti -1c
.RI "\fBMatrix4\fP (T m00, T m01, T m02, T m03, T m10, T m11, T m12, T m13, T m20, T m21, T m22, T m23, T m30, T m31, T m32, T m33)"
.br
.ti -1c
.RI "void \fBMakeOrthographic\fP (T width, T height, T depth)"
.br
.ti -1c
.RI "const T * \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "T \fBGet11\fP (void) const"
.br
.ti -1c
.RI "T \fBGet12\fP (void) const"
.br
.ti -1c
.RI "T \fBGet13\fP (void) const"
.br
.ti -1c
.RI "T \fBGet14\fP (void) const"
.br
.ti -1c
.RI "T \fBGet21\fP (void) const"
.br
.ti -1c
.RI "T \fBGet22\fP (void) const"
.br
.ti -1c
.RI "T \fBGet23\fP (void) const"
.br
.ti -1c
.RI "T \fBGet24\fP (void) const"
.br
.ti -1c
.RI "T \fBGet31\fP (void) const"
.br
.ti -1c
.RI "T \fBGet32\fP (void) const"
.br
.ti -1c
.RI "T \fBGet33\fP (void) const"
.br
.ti -1c
.RI "T \fBGet34\fP (void) const"
.br
.ti -1c
.RI "T \fBGet41\fP (void) const"
.br
.ti -1c
.RI "T \fBGet42\fP (void) const"
.br
.ti -1c
.RI "T \fBGet43\fP (void) const"
.br
.ti -1c
.RI "T \fBGet44\fP (void) const"
.br
.ti -1c
.RI "\fBMatrix4\fP< T > & \fBoperator=\fP (const \fBMatrix4\fP< T > &M)"
.br
.ti -1c
.RI "\fBMatrix4\fP< T > \fBoperator*\fP (const \fBMatrix4\fP< T > &RHM)"
.br
.ti -1c
.RI "\fBMatrix4\fP< T > & \fBoperator*=\fP (\fBMatrix4\fP< T > &RHM)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBMatrix4\fP \fBTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBTranslate\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBScale\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBScale\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBLookAt\fP (const \fBPoint\fP &cameraPos, const \fBPoint\fP &target, const \fBVector4\fP &up)"
.br
.ti -1c
.RI "static \fBMatrix4\fP \fBFPSView\fP (const \fBVector4\fP &cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBF32\fP \fB_Cofactor\fP (const \fBVector4\fP &col1, const \fBVector4\fP &col2, const \fBVector4\fP &col3) const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBVector4\fP \fB_data\fP [4]"
.br
.RI "The matrix itself, represented by 4 \fBVector4\fP in an array\&. "
.ti -1c
.RI "T \fB_m\fP [16]"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>
.br
class KillerMath::Matrix4< T >"
The \fBMatrix4\fP is a 4x4 Matrix meant to be mathematically sound\&. The functions found here have been tested and are built according to linear algebra rules\&. The Matrices are column major to adhere to the format used within OpenGL\&.
.PP
The data for the class is represented by an array of \fBVector4\fP\&. This means that you can index into a specific element of the Matrix, say, colume 2, row 1 by using [2][1]\&. In the rest of the this documentation, this type of value will be represented by the term mrowcolumn\&. For example, colum 2, row 1 will look like m21, read m two one\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > Matrix4::Matrix4 (void)"
Default constructor\&. Sets all values to 0, except for m33\&. 
.SS "template<typename T > Matrix4::Matrix4 (\fBF32\fP m00, \fBF32\fP m01, \fBF32\fP m02, \fBF32\fP m03, \fBF32\fP m10, \fBF32\fP m11, \fBF32\fP m12, \fBF32\fP m13, \fBF32\fP m20, \fBF32\fP m21, \fBF32\fP m22, \fBF32\fP m23, \fBF32\fP m30, \fBF32\fP m31, \fBF32\fP m32, \fBF32\fP m33)"
All value constructor\&. Takes a list of values and turns them into a \fBMatrix4\fP of the same mapping\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm00\fP is the value for element m00\&. 
.br
\fIm01\fP is the value for element m01\&. 
.br
\fIm02\fP is the value for element m02 
.br
\fIm03\fP is the value for element m03\&. 
.br
\fIm10\fP is the value for element m10\&. 
.br
\fIm11\fP is the value for element m11\&. 
.br
\fIm12\fP is the value for element m12 
.br
\fIm13\fP is the value for element m13\&. 
.br
\fIm20\fP is the value for element m20\&. 
.br
\fIm21\fP is the value for element m21\&. 
.br
\fIm22\fP is the value for element m22 
.br
\fIm23\fP is the value for element m23\&. 
.br
\fIm30\fP is the value for element m30\&. 
.br
\fIm31\fP is the value for element m31\&. 
.br
\fIm32\fP is the value for element m32 
.br
\fIm33\fP is the value for element m33\&. 
.RE
.PP

.SS "template<typename T > Matrix4::Matrix4 (const \fBMatrix4\fP< T > & M)"
Copy Constructor\&. Calls \fBMatrix4\fP::[] to, which will copy the \fBVector4\fP from each colume of M into this Matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP is the matrix to copy into this one\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename T > \fBF32\fP Matrix4::_Cofactor (const \fBVector4\fP & col1, const \fBVector4\fP & col2, const \fBVector4\fP & col3) const\fC [private]\fP"
Returns the cofactor for the sub matrix made up of the 3 \fBVector4\fP passed in\&. This is used in Matrix4::Inverse as part of what is called a Classic Adjoint\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcol1\fP is the first column of the sub matrix\&. 
.br
\fIcol2\fP is the second column of the sub matrix\&. 
.br
\fIcol3\fP is the fourth column of the sub matrix\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::AddRotateX (\fBF32\fP val)"
Creates rotation around the x axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::AddRotateY (\fBF32\fP val)"
Creates rotation around the y axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Degree of rotation around y axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::AddRotateZ (\fBF32\fP val)"
Creates rotation around the z axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIz\fP Degree of rotation around z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::AddRotation (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Creates rotation around the x, y and z axis, in that order, without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Not working at all\&. The math is wrong, and rotations are not working in general\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around the x axis\&. Calls \fBRADIAN()\fP 
.br
\fIy\fP Degree of rotation around the y axis\&. Calls \fBRADIAN()\fP 
.br
\fIz\fP Degree of rotation around the z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::AddScale (\fBF32\fP xVal, \fBF32\fP yVal)"
Increases the scaling translation in 2D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Value of scale on x axis\&. 
.br
\fIy\fP Value of scale on y axis\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::AddScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Increases the scaling translation in 3D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Value of scale on x axis\&. 
.br
\fIy\fP Value of scale on y axis\&. 
.br
\fIz\fP Value of scale on z axis\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::AddScale (const \fBVector4\fP & vec)"
Increases the scaling translation equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values that will increase the scale\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::AddTranslate (\fBF32\fP xVal, \fBF32\fP yVal)"
Increases the current translation of this matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value of x axis translation\&. 
.br
\fIy\fP is the value of y axis translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::AddTranslate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Increases the current translation of this matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value of x axis translation\&. 
.br
\fIy\fP is the value of y axis translation\&. 
.br
\fIz\fP is the value of z axis translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::AddTranslate (const \fBVector4\fP & vec)"
Increases the current translation of this matrix equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values that will be used for the translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::ComponentMulti (const \fBMatrix4\fP< T > & M)"
Also known as a straight multiplication\&. Multiplies each value of this \fBMatrix4\fP by the matching value of M\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP \fBMatrix4\fP&\&. Right hand value to multiply by\&. 
.RE
.PP

.SS "template<typename T > \fBF32\fP Matrix4::Determinate (void) const"
Returns the determinate of this matrix\&. This has many uses, and if you are not sure what a determinate is, I have a lot of books you can read\&.\&.\&. 
.SS "template<typename T > \fBMatrix4\fP Matrix4::FPSView (const \fBVector4\fP & cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)\fC [static]\fP"
Similar to \fBMatrix4::LookAt\fP, this function will create a matrix that can be used to translate entities such that they appear as if to have moved according to a position, pitch and yaw\&. This is usually cached for the camera to be used in the graphica computations\&. Euler angles are assumed when setting the matrix up\&. 
.br
\fBParameters:\fP
.RS 4
\fIcameraPos\fP is the position of the camera in world space\&. 
.br
\fIpitch\fP is the up/down pitch of the camera in degrees\&. -90 < pitch < 90\&. 
.br
\fIyas\fP is the right/left yaw of the camera in degress\&. 0 < yaw < 360\&. 
.RE
.PP

.SS "template<typename T > const std::vector< \fBF32\fP > Matrix4::GetElems (void) const"
Return the array containing all the elements\&. 
.SS "template<typename T > \fBMatrix4\fP Matrix4::GetInverse (void) const"
Returns a matrix that is the inverse of this one\&. Warning, very expensive function to call\&. 
.SS "template<typename T > \fBMatrix4\fP Matrix4::LookAt (const \fBPoint\fP & cameraPos, const \fBPoint\fP & target, const \fBVector4\fP & up)\fC [static]\fP"
Returns a matrix that can translate other entities so that they appear as if they were looking down a target axis from a target position\&. This is used mostly with the camera\&. A right handed coordinate system is assumed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcameraPos\fP is the position of the camera in world space\&. This will be the 'location' of the camera for the look at\&. 
.br
\fItarget\fP is the axis down which the camera should look\&. You can also think of this as the target in space the camera should face\&. 
.br
\fIup\fP is the direction considered to be up for the camera\&. 
.RE
.PP

.SS "template<typename T > void \fBKillerMath::Matrix4\fP< T >::MakeIdentity (void)\fC [inline]\fP"
Sets all values of the \fBMatrix4\fP to 0, with the diagnal set to 1\&. 
.SS "template<typename T > void Matrix4::MakeOrthographic (\fBF32\fP left, \fBF32\fP right, \fBF32\fP bottom, \fBF32\fP top, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
Resets the \fBMatrix4\fP, then sets the values up as an Orthographic projection\&. Calls MakeIdentiy()\&. The viewport values are usually based on the dimensions of the window, but could be made smaller\&. 
.PP
\fBParameters:\fP
.RS 4
\fIleft\fP represents the number of pixels from the center to the left boundary of the view frustum\&. 
.br
\fIright\fP represents the number of pixels from the center to the right boundary of the view frustum\&. 
.br
\fIbottom\fP represents the number of pixels from the center to the bottom boundary of the view frustum\&. 
.br
\fItop\fP represents the number of pixels from the center to the top boundary of the view frustum\&. 
.br
\fInearPlane\fP represents the number of pixels from the center to the nearest boundary of the view frustum\&. 
.br
\fIfarPlane\fP represents the number of pixels from the center to the furthest boundary of the view furstum\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::MakePerspective (\fBF32\fP fieldOfView, \fBF32\fP aspectRatio, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
Resets the \fBMatrix4\fP, then sets the values up as a Perspective \fBMatrix4\fP\&. Instead of using the dimensions of the viewport, this version uses slightly differently ideas\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfieldOfview\fP is the angle of the fields of view\&. Good values include 90 or 120\&. Will change the skew of the view\&. 
.br
\fIaspectration\fP is the Width/height of the screen, but can be set to more specific values like 4:3 or 16:9\&. 
.br
\fInearPlane\fP represents the number of pixels from the center to the nearest boundary of the view frustum\&. 
.br
\fIfarPlane\fP represents the number of pixels from the center to the furthest boundary of the view furstum\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::operator* (const \fBMatrix4\fP< T > & mat) const"
Performs a \fBMatrix4\fP style multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP is the matrix that is multiplied by this matrix\&. 
.RE
.PP

.SS "template<typename T > \fBVector4\fP Matrix4::operator* (const \fBVector4\fP & vec) const"
Performs \fBMatrix4\fP multiplication with \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the vector that is multiplied by this matrix\&. 
.RE
.PP

.SS "template<typename T > \fBPoint\fP Matrix4::operator* (const \fBPoint\fP & point) const"
Performs \fBMatrix4\fP multiplication with \fBPoint\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP is the vector that is multiplied by this matrix\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP & Matrix4::operator/= (\fBF32\fP val)"
Divides each element of this matrix, setting it to the results\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value that this matrix is divided by\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP & Matrix4::operator= (const \fBMatrix4\fP< T > & mat)"
Assigns this matrix to be equal to the values of another\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP is the matrix that is copied\&. 
.RE
.PP

.SS "template<typename T > const \fBVector4\fP& \fBKillerMath::Matrix4\fP< T >::operator[] (int i) const\fC [inline]\fP"
Used to access the ith column of the \fBMatrix4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index to return\&. Cannot be greater than 3\&. There are only 4 columns\&. 
.RE
.PP

.SS "template<typename T > \fBVector4\fP& \fBKillerMath::Matrix4\fP< T >::operator[] (int i)\fC [inline]\fP"
Used to access the ith column of the \fBMatrix4\fP\&. This version allows you to edit the values in the column\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index to return\&. Cannot be greater than 3\&. There are only 4 columns\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::Reset (\fBF32\fP val = \fC0\&.0f\fP)"
Sets all the values of the \fBMatrix4\fP to 0, with the diagnal set to val\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Value of the diagnal of the \fBMatrix4\fP\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::RotateX (\fBF32\fP val)\fC [static]\fP"
Creates a matrix that will perform a rotation around the x axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the angle to rotate in degrees\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::RotateY (\fBF32\fP val)\fC [static]\fP"
Creates a matrix that will perform a rotation around the y axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the angle to rotate in degrees\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::RotateZ (\fBF32\fP val)\fC [static]\fP"
Creates a matrix that will perform a rotation around the z axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the angle to rotate in degrees\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Scale (\fBF32\fP xVal, \fBF32\fP yVal)\fC [static]\fP"
Creates a matrix that will perform a scaling transformation in 2D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Scale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [static]\fP"
Creates a matrix that will perform a scaling transformation in 3D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.br
\fIzVal\fP is the amount to scale in the z axis\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Scale (const \fBVector4\fP & vec)\fC [static]\fP"
Creates a matrix that will perform a scaling translation equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Scale (const \fBVector3\fP & vec)\fC [static]\fP"
Creates a matrix that will perform a scaling translation equal to the x y and z values in a \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetAsInverse (const \fBMatrix4\fP< T > & mat)"
Changes this matrix to equal the inverse of another\&. Warning, very expsenive function to call\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP inverse will be set to this matrix\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetFPSView (const \fBVector4\fP & cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)"
Similar to \fBMatrix4::LookAt\fP, this function will set this matrix so that it can be used to translate entities such that they appear as if to have moved according to a position, pitch and yaw\&. This is usually cached for the camera to be used in the graphica computations\&. Euler angles are assumed when setting the matrix up\&. 
.br
\fBParameters:\fP
.RS 4
\fIcameraPos\fP is the position of the camera in world space\&. 
.br
\fIpitch\fP is the up/down pitch of the camera in degrees\&. -90 < pitch < 90\&. 
.br
\fIyas\fP is the right/left yaw of the camera in degress\&. 0 < yaw < 360\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetInverse (void)"
Changes this matrix to equal its inverse\&. Warning, this is a very expensive function to call\&. 
.SS "template<typename T > void Matrix4::SetLookAt (const \fBVector4\fP & cameraPos, const \fBVector4\fP & target, const \fBVector4\fP & up)"
Sets this matrix to translate other entities so that they appear as if they were looking down a target axis from a target position\&. This is used mostly with the camera\&. A right handed coordinate system is assumed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcameraPos\fP is the position of the camera in world space\&. This will be the 'location' of the camera for the look at\&. 
.br
\fItarget\fP is the axis down which the camera should look\&. You can also think of this as the target in space the camera should face\&. 
.br
\fIup\fP is the direction considered to be up for the camera\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetOrientation (const \fBQuaternion\fP & q)"
Sets the rotational transform of the matrix equal to the orientation contained in teh \fBQuaternion\fP\&. This is currently untested\&. 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP conatins the orientation to set\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetOrientationAndPosition (const \fBQuaternion\fP & q, const \fBVector4\fP & v)"
A helper functions that will set the rotational transform and position at the same time\&. This is currently untested\&. 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP contains the orientation to set\&. 
.br
\fIv\fP contains the position to set, as a translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetOrientationAndPosition (const \fBQuaternion\fP & q, const \fBPoint\fP & p)"
A helper functions that will set the rotational transform and position at the same time\&. This is currently untested\&. 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP contains the orientation to set\&. 
.br
\fIp\fP contains the position to set, as a translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetRotate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Resets the \fBMatrix4\fP and creates an \fBMatrix4\fP which will perform a rotation around the x, y and z axis in that order\&. Calls \fBMakeIdentity()\fP 
.PP
\fBBug\fP
.RS 4
Not working at all\&. The math is wrong, and rotations are not working in general\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around the x axis\&. Calls \fBRADIAN()\fP 
.br
\fIy\fP Degree of rotation around the y axis\&. Calls \fBRADIAN()\fP 
.br
\fIz\fP Degree of rotation around the z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::SetRotateX (\fBF32\fP val)"
Resets \fBMatrix4\fP and creates rotation around the x axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::SetRotateY (\fBF32\fP val)"
Resets \fBMatrix4\fP and creates rotation around the y axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Degree of rotation around y axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::SetRotateZ (\fBF32\fP val)"
Resets \fBMatrix4\fP and creates rotation around the z axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIz\fP Degree of rotation around z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "template<typename T > void Matrix4::SetScale (\fBF32\fP xVal, \fBF32\fP yVal)"
Sets this matrix to perform a scaling transformation in 2D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Sets this matrix to perform a scaling transformation in 3D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.br
\fIzVal\fP is the amount to scale in the z axis\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetScale (const \fBVector4\fP & vec)"
Sets this matrix to perform a scaling translation equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetTranslate (\fBF32\fP xVal, \fBF32\fP yVal)"
Sets a 2D translation for this matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value of x axis translation\&. 
.br
\fIy\fP is the value of y axis translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetTranslate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Sets a 3D translation for this matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP is the value of x axis translation\&. 
.br
\fIy\fP is the value of y axis translation\&. 
.br
\fIz\fP is the value of z axis translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::SetTranslate (const \fBVector4\fP & vec)"
Sets a translation for this matrix equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values that will be used for the translation\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Transform3x3 (const \fBMatrix4\fP< T > & mat) const"
Helper function that will return the transformed version of a matrix by the affine transformation of this matrix\&. This means that it will not include any translation\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP is transformed\&. 
.RE
.PP

.SS "template<typename T > \fBVector4\fP Matrix4::Transform3x3 (const \fBVector4\fP & vec) const"
Helper function that will return the transformed version of a vector by the affine transformation fo this matrix\&. This means that it will not include any translation\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is transformed\&. 
.RE
.PP

.SS "template<typename T > \fBVector4\fP Matrix4::TransformInverse (const \fBVector4\fP & vec) const"
Returns a \fBVector4\fP transformed by the inverse of this matrix\&. Warning, this is a costly call\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the vectored used to performed the transformation\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Translate (\fBF32\fP xVal, \fBF32\fP yVal)\fC [static]\fP"
Creates a 2D translation matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to translate on the x axis\&. 
.br
\fIyVal\fP is the amount to translate on the y axis\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Translate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [static]\fP"
Creates a 3D translation Matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to translate on the x axis\&. 
.br
\fIyVal\fP is the amount to translate on the y axis\&. 
.br
\fIzVal\fP is the amount to translate on the z axis\&. 
.RE
.PP

.SS "template<typename T > \fBMatrix4\fP Matrix4::Translate (const \fBVector4\fP & vec)\fC [static]\fP"
Creates a translation matrix equal to the x y and z values in the \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values that will be used for the translation\&. 
.RE
.PP

.SS "template<typename T > void Matrix4::Transpose (void)"
Reverses the Column/Row order of the \fBMatrix4\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

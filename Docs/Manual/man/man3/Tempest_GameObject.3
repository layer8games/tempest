.TH "Tempest::GameObject" 3 "Mon Mar 2 2020" "Tempest" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Tempest::GameObject
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <GameObject\&.h>\fP
.PP
Inherited by \fBTempest::EnvironmentObject\fP, and \fBTempest::Glyph\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "TEMPEST_API \fBGameObject\fP (void)"
.br
.RI "Sets up initial values\&. Most of them are set to 0\&. Active is set to true\&. "
.ti -1c
.RI "TEMPEST_API \fBGameObject\fP (const \fBGameObject\fP &obj)"
.br
.RI "Copies a \fBGameObject\fP\&. "
.ti -1c
.RI "virtual TEMPEST_API \fB~GameObject\fP (void)"
.br
.RI "Deletes the buffers that are used for the shader\&. These should probably be moved\&. "
.ti -1c
.RI "virtual void \fBv_Update\fP (void)=0"
.br
.ti -1c
.RI "virtual void \fBv_Render\fP (void)"
.br
.ti -1c
.RI "virtual void \fBv_Awake\fP (void)"
.br
.RI "Called when the Object is made active\&. Calls DefaultAwake\&. Can be overloaded if you need something different\&. 
.br
 "
.ti -1c
.RI "virtual void \fBv_OnEvent\fP (\fBEvent\fP event)"
.br
.ti -1c
.RI "TEMPEST_API void \fBUpdateInternals\fP (void)"
.br
.ti -1c
.RI "TEMPEST_API void \fBMakeSprite\fP (void)"
.br
.RI "Calls all the needed functions to make this Object act like a sprite\&. This is a replacement for a full sprite class\&. "
.ti -1c
.RI "const \fBTM::Matrix4\fP & \fBGetModelMatrix\fP (void) const"
.br
.ti -1c
.RI "const \fBTM::Matrix4\fP \fBGetModelMatrixRot\fP (void) const"
.br
.ti -1c
.RI "const bool \fBGetActive\fP (void) const"
.br
.RI "Get the active state of the \fBGameObject\fP\&. Returns true if is active update and active render 
.br
 "
.ti -1c
.RI "void \fBSetActive\fP (bool state)"
.br
.ti -1c
.RI "void \fBSetActive\fP (void)"
.br
.RI "Sets update and render to active and calls v_Awake 
.br
 "
.ti -1c
.RI "void \fBSetInactive\fP (void)"
.br
.RI "Sets update and render to inactive\&. 
.br
 "
.ti -1c
.RI "const bool \fBGetActiveUpdate\fP (void) const"
.br
.RI "Returns true if update is active\&. 
.br
 "
.ti -1c
.RI "void \fBSetActiveUpdate\fP (bool state)"
.br
.ti -1c
.RI "void \fBSetActiveUpdate\fP (void)"
.br
.RI "Set update to active\&. v_Awake is not called\&. 
.br
 "
.ti -1c
.RI "void \fBSetInactiveUpdate\fP (void)"
.br
.RI "Set update to not active\&. 
.br
 "
.ti -1c
.RI "const bool \fBGetActiveRender\fP (void) const"
.br
.RI "Returns true if render is active\&. 
.br
 "
.ti -1c
.RI "void \fBSetActiveRender\fP (bool state)"
.br
.ti -1c
.RI "void \fBSetActiveRender\fP (void)"
.br
.RI "Set render to active\&. v_Awake is not called\&. "
.ti -1c
.RI "void \fBSetInactiveRender\fP (void)"
.br
.RI "Set render to not active\&. 
.br
 "
.ti -1c
.RI "bool \fBIsSprite\fP (void) const"
.br
.RI "Returns true is the \fBGameObject\fP has had MakeSprite called, or is considered to be a sprite\&. 
.br
 "
.ti -1c
.RI "const \fBU32\fP \fBGetID\fP (void) const"
.br
.RI "Returns the ID for the \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "const \fBTM::Point\fP & \fBGetPosition\fP (void) const"
.br
.RI "Returns the current position of the \fBGameObject\fP in world space\&. 
.br
 "
.ti -1c
.RI "void \fBSetPosition\fP (const \fBTM::Point\fP &pos)"
.br
.ti -1c
.RI "void \fBSetPosition\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetPosition\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetPositionX\fP (\fBF32\fP xval)"
.br
.ti -1c
.RI "void \fBSetPositionY\fP (\fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetPositionZ\fP (\fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScaledPosition\fP (const \fBTM::Vector4\fP &pos, \fBF32\fP scale)"
.br
.ti -1c
.RI "void \fBAddScaledPosition\fP (const \fBTM::Vector3\fP &pos, \fBF32\fP scale)"
.br
.ti -1c
.RI "void \fBAddScaledPosition\fP (const \fBTM::Point\fP &point, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBTM::Vector3\fP & \fBGetScale\fP (void) const"
.br
.RI "Return the current scale factor for the \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "void \fBSetScale\fP (const \fBTM::Vector3\fP &scale)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP val)"
.br
.RI "Set all values of the scale to a single value\&. Bounding Box is updated\&. "
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "const \fBTM::Quaternion\fP & \fBGetOrientation\fP (void) const"
.br
.RI "Returns the current orientation of the \fBGameObject\fP 
.br
 "
.ti -1c
.RI "void \fBSetOrientation\fP (const \fBTM::Quaternion\fP &q)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (\fBF32\fP wVal, \fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScaledOrientation\fP (const \fBTM::Vector4\fP vec, \fBF32\fP scale)"
.br
.ti -1c
.RI "void \fBNormalizeOrientation\fP (void)"
.br
.RI "Changes the length of the orientation to be 1\&.0\&. Calls Quaternion::Normalize\&. "
.ti -1c
.RI "void \fBSetColor\fP (const \fBColor\fP &col)"
.br
.ti -1c
.RI "void \fBSetColor\fP (\fBF32\fP red, \fBF32\fP green, \fBF32\fP blue)"
.br
.ti -1c
.RI "const \fBColor\fP & \fBGetColor\fP (void) const"
.br
.RI "Return the color of the \fBGameObject\fP 
.br
 "
.ti -1c
.RI "bool \fBOverlapCheck\fP (const shared_ptr< \fBGameObject\fP > other)"
.br
.ti -1c
.RI "const \fBTC::AABB\fP & \fBGetBounding\fP (void) const"
.br
.RI "Return the bounding boxe of this \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "void \fBSetTexture\fP (p_Texture texture)"
.br
.ti -1c
.RI "p_Texture \fBGetTexture\fP (void) const"
.br
.RI "Return the current texture pointer for the \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "void \fBBindTexture\fP (bool state=true)"
.br
.RI "Helper wrapper to call \fBTexture::Bind\fP on the texture that is saved on this \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "const p_Shader \fBGetShader\fP (void) const"
.br
.RI "Returns the current shader for this \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "void \fBSetShader\fP (const p_Shader shader)"
.br
.RI "Change the shader for this \fBGameObject\fP\&. 
.br
 "
.ti -1c
.RI "void \fBSetMesh\fP (p_Mesh mesh)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "TEMPEST_API void \fBDefaultAwake\fP (void)"
.br
.RI "Default code to be run when v_Awake is called\&. 
.br
 "
.ti -1c
.RI "TEMPEST_API void \fBDefaultRender\fP (void)"
.br
.RI "Default code to Render the Object\&. "
.ti -1c
.RI "TEMPEST_API void \fBDefaultUpdate\fP (void)"
.br
.RI "Default behavior that should be considered when calling Update on an \fBGameObject\fP\&. This calls UpdateInternals\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "p_Shader \fB_shader\fP"
.br
.RI "\fBShader\fP used for rendering\&. Should come from the \fBShaderManager\fP\&. Set to null by default\&. "
.ti -1c
.RI "p_Mesh \fB_mesh\fP"
.br
.RI "Collection of vertices that make up the body of the rendered object\&. "
.ti -1c
.RI "\fBTC::AABB\fP \fB_boundingBox\fP"
.br
.RI "Collision bounding box for the object\&. Is active and set up by default\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fB_CalculateCachedData\fP (void)"
.br
.RI "Creates a data cache of the model to world transformation matrix\&. This can help with objects that use their matrix a lot\&. 
.br
 "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBTM::Matrix4\fP \fB_modelTOWorldCache\fP"
.br
.RI "Cache of the model to world transformation matrix\&. "
.ti -1c
.RI "\fBTM::Point\fP \fB_position\fP"
.br
.RI "Position of the object in world space\&. "
.ti -1c
.RI "\fBTM::Vector3\fP \fB_scale\fP"
.br
.RI "Scale of the object in world space\&. "
.ti -1c
.RI "\fBTM::Quaternion\fP \fB_orientation\fP"
.br
.RI "Orientation of the object in world space\&. Untested\&. "
.ti -1c
.RI "\fBColor\fP \fB_color\fP"
.br
.RI "\fBColor\fP that should be used to tint the object\&. How it affects the object depends on what shader you are using\&. "
.ti -1c
.RI "p_Texture \fB_texture\fP"
.br
.RI "\fBTexture\fP used when rendering the object\&. Set to null by default\&. "
.ti -1c
.RI "bool \fB_activeUpdate\fP"
.br
.RI "\fBState\fP of the object in the update loop\&. If true, v_Update will be called\&. "
.ti -1c
.RI "bool \fB_activeRender\fP"
.br
.RI "\fBState\fP of the object in the render loop\&. If true, v_Render will be called\&. "
.ti -1c
.RI "bool \fB_isSprite\fP"
.br
.RI "Helper flag to let the engine know if this object is a 2D sprite vs a 3D model\&. "
.ti -1c
.RI "\fBU32\fP \fB_ID\fP"
.br
.RI "ID should be unique, but this system needs to be changed\&. "
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBU32\fP \fB_nextID\fP = 1"
.br
.RI "This is an early attempt to ensure that all ID as unique\&. This is a flawed approach\&. 
.br
 "
.in -1c
.SH "Detailed Description"
.PP 
The \fBGameObject\fP may be the backbone of Tempest\&. This is the basic object that will exist in the game\&. It is the root of all rendered and interactive objects in the games\&. It is not a manager\&. This is an abstract class, so it is meant to be full implemented as needed\&. This holds the generic ideas of what makes up the most basic type of Object in the game \fBLevel\fP\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Tempest::GameObject::AddScaledOrientation (const \fBTM::Vector4\fP vec, \fBF32\fP scale)\fC [inline]\fP"
Update to orientation by a Vector4 value scaled\&. This called Quaternion::AddScaledVector 
.PP
\fBParameters\fP
.RS 4
\fIvec\fP is a converted value to scale the orientation by\&. 
.br
\fIscale\fP is the value to scale the orientation by\&. 
.RE
.PP

.SS "void Tempest::GameObject::AddScaledPosition (const \fBTM::Point\fP & point, \fBF32\fP scale)\fC [inline]\fP"
Set the Position of the \fBGameObject\fP scaled by a factor\&. Point::AddScaledVector is called\&. Bounding Box is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos\fP is the new position for the object\&. 
.br
\fIscale\fP is the factor that the pos is scaled by\&. 
.br
 
.RE
.PP

.SS "void Tempest::GameObject::AddScaledPosition (const \fBTM::Vector3\fP & pos, \fBF32\fP scale)\fC [inline]\fP"
Set the Position of the \fBGameObject\fP scaled by a factor\&. Vector3::AddScaledVector is called\&. Bounding Box is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos\fP is the new position for the object\&. 
.br
\fIscale\fP is the factor that the pos is scaled by\&. 
.RE
.PP

.SS "void Tempest::GameObject::AddScaledPosition (const \fBTM::Vector4\fP & pos, \fBF32\fP scale)\fC [inline]\fP"
Set the Position of the \fBGameObject\fP scaled by a factor\&. Vector4::AddScaledVector is called\&. Bounding Box is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos\fP is the new position for the object\&. 
.br
\fIscale\fP is the factor that the pos is scaled by\&. 
.RE
.PP

.SS "const \fBTM::Matrix4\fP& Tempest::GameObject::GetModelMatrix (void) const\fC [inline]\fP"
Returns the 'view' matrix, the transform needed to get the object transformed into world space\&. This is used by opengl for rendering\&. 
.SS "const \fBTM::Matrix4\fP Tempest::GameObject::GetModelMatrixRot (void) const\fC [inline]\fP"
A temporary experiment meant to return the 'view' matrix, with the rotations\&. This is a first attempt to make rotations work, but it didn't really work out very well\&. Issue #51 should fix this\&. 
.br
 
.SS "bool Tempest::GameObject::OverlapCheck (const shared_ptr< \fBGameObject\fP > other)\fC [inline]\fP"
Helper wrapper for AABB::TestCollission\&. This checks if the Bounding Box of another \fBGameObject\fP is overlapping this \fBGameObject\fP\&. Returns true if the bounding boxes overlap\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP is the \fBGameObject\fP to test against\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetActive (bool state)\fC [inline]\fP"
Sets the active sate of the object\&. If either update or render is in active, v_Awake is called\&. Both update and rendering are set to active\&. 
.PP
\fBParameters\fP
.RS 4
\fIstate\fP is the new state, no default value\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetActiveRender (bool state)\fC [inline]\fP"
Set a new state for render\&. v_Awake is not called\&. 
.PP
\fBParameters\fP
.RS 4
\fIstate\fP is the new state for render\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetActiveUpdate (bool state)\fC [inline]\fP"
Set active update state\&. v_Awake is not called\&. 
.PP
\fBParameters\fP
.RS 4
\fIstate\fP is the new state for update\&. 
.br
 
.RE
.PP

.SS "void Tempest::GameObject::SetColor (const \fBColor\fP & col)\fC [inline]\fP"
Change the color of the \fBGameObject\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIcol\fP is the new color\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetColor (\fBF32\fP red, \fBF32\fP green, \fBF32\fP blue)\fC [inline]\fP"
Change the color of the \fBGameObject\fP without having to create a \fBColor\fP object\&. Alpha is ommited\&. 
.PP
\fBParameters\fP
.RS 4
\fIred\fP is the value of red in the color, should range from 0\&.0f to 1\&.0f\&. 
.br
\fIgreen\fP is the value of green in the color, should range from 0\&.0f to 1\&.0f\&. 
.br
\fIblue\fP is the value of blue in the color, should range from 0\&.0f to 1\&.0f\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetOrientation (const \fBTM::Quaternion\fP & q)\fC [inline]\fP"
Set a new orientation for the \fBGameObject\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIq\fP is the new orienation\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetOrientation (\fBF32\fP val)\fC [inline]\fP"
Set the orienation of the \fBGameObject\fP to a single value \\pararm val is the value all 4 components of the orientation will be set to\&. 
.SS "void Tempest::GameObject::SetOrientation (\fBF32\fP wVal, \fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [inline]\fP"
Set the orientation of the \fBGameObject\fP without having to create a Quaternion 
.PP
\fBParameters\fP
.RS 4
\fIwVal\fP sets the w component\&. 
.br
\fIxVal\fP sets the x component\&. 
.br
\fIyVal\fP sets the y component\&. 
.br
\fIzVal\fP sets the z component\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetPosition (const \fBTM::Point\fP & pos)\fC [inline]\fP"
Set the position of the \fBGameObject\fP in world space\&. The bounding boxes center location is also updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos\fP is the new position for the object and bounding box\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetPosition (\fBF32\fP xVal, \fBF32\fP yVal)\fC [inline]\fP"
Set the x and y values of the \fBGameObject\fP in world space\&. The bounding box center is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIxVal\fP is the new x offset\&. 
.br
\fIyVal\fP is the new y offset\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetPosition (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [inline]\fP"
Set the x, y and z values of the \fBGameObject\fP in world space\&. The bounding box center is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIxVal\fP is the new x offset\&. 
.br
\fIyVal\fP is the new y offset\&. 
.br
\fIzVal\fP is the new z offset\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetPositionX (\fBF32\fP xval)\fC [inline]\fP"
Set just the x value of the \fBGameObject\fP in world space\&. Bounding box center is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIxval\fP is the new x offset\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetPositionY (\fBF32\fP yVal)\fC [inline]\fP"
Set just the y value of the \fBGameObject\fP in world space\&. Bounding box center is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIyVal\fP is the new y offset\&. 
.br
 
.RE
.PP

.SS "void Tempest::GameObject::SetPositionZ (\fBF32\fP zVal)\fC [inline]\fP"
Set just the z value of the \fBGameObject\fP in world space\&. Bounding box center is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIzVal\fP is the new z offset\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetScale (const \fBTM::Vector3\fP & scale)\fC [inline]\fP"
Sets a new scale factor for the \fBGameObject\fP\&. Bounding Box is updated\&. 
.PP
\fBParameters\fP
.RS 4
\fIscale\fP is set as the new scale\&. No matrix is updated\&. 
.RE
.PP

.SS "void Tempest::GameObject::SetScale (\fBF32\fP xVal, \fBF32\fP yVal)\fC [inline]\fP"
Set x and y scale factors\&. Bounding Box is updated\&. \\pararm xVal is the new scale factor on the x axis\&. \\pararm yVal is the new scale factor on the y axis\&. 
.SS "void Tempest::GameObject::SetScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [inline]\fP"
Set x, y and z scale factors\&. Bounding Box is updated\&. \\pararm xVal is the new scale factor on the x axis\&. \\pararm yVal is the new scale factor on the y axis\&. \\pararm zVal is the new scale factor on the z axis\&. 
.SS "void Tempest::GameObject::SetTexture (p_Texture texture)\fC [inline]\fP"
Change the texture of the \fBGameObject\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItexture\fP is the new texture for the \fBGameObject\fP\&. 
.RE
.PP

.SS "void GameObject::UpdateInternals (void)"
Calls _CalculateCachedData\&. The idea is that the data for the Object can be cached, and this updates that cache\&. This has some issues since it is not always called\&. 
.br
 
.SS "virtual void Tempest::GameObject::v_OnEvent (\fBEvent\fP event)\fC [inline]\fP, \fC [virtual]\fP"
Handle an event that is passed to this object\&. This behavior is to be defined by each \fBGameObject\fP that is made\&. The default behavior is to ignore the \fBEvent\fP\&. 
.SS "virtual void Tempest::GameObject::v_Render (void)\fC [inline]\fP, \fC [virtual]\fP"
Default Render will check if there is a texture attached to the Object, make the shader on the object active, and will send the vertices that have been added to the object to OpenGL using glDrawArrays\&. This is virtual because it can be overloaded if this is not what you need for rendering\&. 
.SS "virtual void Tempest::GameObject::v_Update (void)\fC [pure virtual]\fP"
Abstract function\&. This update is called one per frame, if the object is registered with the \fBGameObjectManager\fP and is Update Active\&. 
.PP
Implemented in \fBTempest::Glyph\fP, and \fBTempest::EnvironmentObject\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Tempest from the source code\&.

.TH "Tempest::GameObject" 3 "Tue Jan 7 2020" "Tempest" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Tempest::GameObject
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <GameObject\&.h>\fP
.PP
Inherited by \fBTempest::EnvironmentObject\fP, and \fBTempest::Glyph\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "TEMPEST_API \fBGameObject\fP (void)"
.br
.RI "Sets up initial values\&. Most of them are set to 0\&. Active is set to true\&. "
.ti -1c
.RI "TEMPEST_API \fBGameObject\fP (const \fBGameObject\fP &obj)"
.br
.RI "Copies a \fBGameObject\fP\&. "
.ti -1c
.RI "virtual TEMPEST_API \fB~GameObject\fP (void)"
.br
.RI "Deletes the buffers that are used for the shader\&. These should probably be moved\&. "
.ti -1c
.RI "virtual void \fBv_Update\fP (void)=0"
.br
.ti -1c
.RI "virtual TEMPEST_API void \fBv_Render\fP (void)"
.br
.ti -1c
.RI "virtual TEMPEST_API void \fBv_InitBuffers\fP (void)"
.br
.ti -1c
.RI "virtual void \fBv_Awake\fP (void)"
.br
.RI "Called when the Object is made active\&. Calls DefaultAwake\&. Can be overloaded if you need something different\&. "
.ti -1c
.RI "TEMPEST_API void \fBInitOGL\fP (void)"
.br
.RI "Calls glGenVertexArrays and glGenBuffers for the needs of this object\&. "
.ti -1c
.RI "TEMPEST_API void \fBUpdateInternals\fP (void)"
.br
.ti -1c
.RI "TEMPEST_API bool \fBLoadOBJ\fP (string filepath)"
.br
.ti -1c
.RI "TEMPEST_API void \fBLoadMesh\fP (string filepath)"
.br
.ti -1c
.RI "TEMPEST_API void \fBMakeSprite\fP (void)"
.br
.RI "Calls all the needed functions to make this Object act like a sprite\&. This is a replacement for a full sprite class\&. "
.ti -1c
.RI "const \fBTM::Matrix4\fP & \fBGetModelMatrix\fP (void) const"
.br
.ti -1c
.RI "const \fBTM::Matrix4\fP \fBGetModelMatrixRot\fP (void) const"
.br
.ti -1c
.RI "const bool \fBGetActive\fP (void) const"
.br
.ti -1c
.RI "void \fBSetActive\fP (bool state)"
.br
.ti -1c
.RI "void \fBSetActive\fP (void)"
.br
.ti -1c
.RI "void \fBSetInactive\fP (void)"
.br
.ti -1c
.RI "const bool \fBGetActiveUpdate\fP (void) const"
.br
.ti -1c
.RI "void \fBSetActiveUpdate\fP (bool state)"
.br
.ti -1c
.RI "void \fBSetActiveUpdate\fP (void)"
.br
.ti -1c
.RI "void \fBSetInactiveUpdate\fP (void)"
.br
.ti -1c
.RI "const bool \fBGetActiveRender\fP (void) const"
.br
.ti -1c
.RI "void \fBSetActiveRender\fP (bool state)"
.br
.ti -1c
.RI "void \fBSetActiveRender\fP (void)"
.br
.ti -1c
.RI "void \fBSetInactiveRender\fP (void)"
.br
.ti -1c
.RI "bool \fBIsSprite\fP (void) const"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetID\fP (void) const"
.br
.ti -1c
.RI "const \fBTM::Point\fP & \fBGetPosition\fP (void) const"
.br
.ti -1c
.RI "void \fBSetPosition\fP (const \fBTM::Point\fP &pos)"
.br
.ti -1c
.RI "void \fBSetPosition\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetPosition\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetPositionX\fP (\fBF32\fP xval)"
.br
.ti -1c
.RI "void \fBSetPositionY\fP (\fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetPositionZ\fP (\fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScaledPosition\fP (const \fBTM::Vector4\fP &pos, \fBF32\fP scale)"
.br
.ti -1c
.RI "void \fBAddScaledPosition\fP (const \fBTM::Vector3\fP &pos, \fBF32\fP scale)"
.br
.ti -1c
.RI "void \fBAddScaledPosition\fP (const \fBTM::Point\fP &point, \fBF32\fP scale)"
.br
.ti -1c
.RI "const \fBTM::Vector3\fP & \fBGetScale\fP (void) const"
.br
.ti -1c
.RI "void \fBSetScale\fP (const \fBTM::Vector3\fP &scale)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "const \fBTM::Quaternion\fP & \fBGetOrientation\fP (void) const"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (const \fBTM::Quaternion\fP &q)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (\fBF32\fP wVal, \fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScaledOrientation\fP (const \fBTM::Vector4\fP vec, \fBF32\fP scale)"
.br
.ti -1c
.RI "void \fBNormalizeOrientation\fP (void)"
.br
.ti -1c
.RI "void \fBSetColor\fP (const \fBColor\fP &col)"
.br
.ti -1c
.RI "void \fBSetColor\fP (\fBF32\fP red, \fBF32\fP green, \fBF32\fP blue)"
.br
.ti -1c
.RI "void \fBSetColor\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "const \fBColor\fP & \fBGetColor\fP (void) const"
.br
.ti -1c
.RI "bool \fBOverlapCheck\fP (const shared_ptr< \fBGameObject\fP > other)"
.br
.ti -1c
.RI "const \fBTC::AABB\fP & \fBGetBounding\fP (void) const"
.br
.ti -1c
.RI "void \fBSetTexture\fP (shared_ptr< \fBTexture\fP > texture)"
.br
.ti -1c
.RI "shared_ptr< \fBTexture\fP > \fBGetTexture\fP (void) const"
.br
.ti -1c
.RI "void \fBBindTexture\fP (bool state=true)"
.br
.ti -1c
.RI "const shared_ptr< \fBShader\fP > \fBGetShader\fP (void) const"
.br
.ti -1c
.RI "void \fBSetShader\fP (const shared_ptr< \fBShader\fP > shader)"
.br
.ti -1c
.RI "void \fBLoadShader\fP (std::vector< \fBShaderData\fP > shaderData)"
.br
.ti -1c
.RI "void \fBUseShader\fP (bool state=true)"
.br
.ti -1c
.RI "void \fBSetUniform\fP (string name, const \fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetUniform\fP (string name, const \fBTM::Vector4\fP &vec)"
.br
.ti -1c
.RI "void \fBSetUniform\fP (string name, const \fBTM::Vector3\fP &vec)"
.br
.ti -1c
.RI "void \fBSetUniform\fP (string name, const \fBTM::Point\fP &point)"
.br
.ti -1c
.RI "void \fBSetUniform\fP (string name, const \fBTM::Matrix4\fP &mat)"
.br
.ti -1c
.RI "void \fBSetUniformSampler\fP (string name, \fBS32\fP texSlot)"
.br
.ti -1c
.RI "void \fBSetUniform\fP (string name, const \fBColor\fP &col)"
.br
.ti -1c
.RI "void \fBSetUniformVec3\fP (string name, const \fBColor\fP &col)"
.br
.ti -1c
.RI "\fBU32\fP \fBGetNumVertices\fP (void)"
.br
.ti -1c
.RI "void \fBAddVertex\fP (const \fBVertex\fP &vert)"
.br
.ti -1c
.RI "void \fBSetVertices\fP (std::vector< \fBVertex\fP > vertices)"
.br
.ti -1c
.RI "std::vector< \fBVertex\fP > \fBGetVertices\fP (void) const"
.br
.ti -1c
.RI "void \fBAddIndex\fP (\fBU32\fP index)"
.br
.ti -1c
.RI "void \fBSetIndices\fP (std::vector< \fBU32\fP > indices)"
.br
.ti -1c
.RI "std::vector< \fBU32\fP > \fBGetIndices\fP (void) const"
.br
.ti -1c
.RI "GLuint \fBGetVAO\fP (void) const"
.br
.ti -1c
.RI "void \fBBindVAO\fP (bool state=true)"
.br
.ti -1c
.RI "void \fBBindVBO\fP (BufferData buffer, bool state=true)"
.br
.ti -1c
.RI "std::vector< \fBF32\fP > \fBGetUVList\fP (void) const"
.br
.ti -1c
.RI "void \fBSetUVList\fP (std::vector< \fBF32\fP > list)"
.br
.ti -1c
.RI "void \fBAddUV\fP (\fBF32\fP val)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "TEMPEST_API void \fBDefaultAwake\fP (void)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "std::vector< \fBU32\fP > \fB_SplitU32\fP (string text, char delim) const"
.br
.ti -1c
.RI "std::vector< \fBF32\fP > \fB_SplitF32\fP (string text, char delim) const"
.br
.ti -1c
.RI "std::vector< string > \fB_SplitString\fP (string text, char delim) const"
.br
.ti -1c
.RI "void \fB_CalculateCachedData\fP (void)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBVertex\fP > \fB_vertices\fP"
.br
.ti -1c
.RI "std::vector< \fBU32\fP > \fB_indices\fP"
.br
.ti -1c
.RI "std::vector< \fBF32\fP > \fB_uvList\fP"
.br
.ti -1c
.RI "\fBTM::Matrix4\fP \fB_modelTOWorldCache\fP"
.br
.ti -1c
.RI "\fBTM::Point\fP \fB_position\fP"
.br
.ti -1c
.RI "\fBTM::Vector3\fP \fB_scale\fP"
.br
.ti -1c
.RI "\fBTM::Quaternion\fP \fB_orientation\fP"
.br
.ti -1c
.RI "\fBColor\fP \fB_color\fP"
.br
.ti -1c
.RI "\fBTC::AABB\fP \fB_boundingBox\fP"
.br
.ti -1c
.RI "shared_ptr< \fBTexture\fP > \fB_texture\fP"
.br
.ti -1c
.RI "shared_ptr< \fBShader\fP > \fB_shader\fP"
.br
.ti -1c
.RI "bool \fB_activeUpdate\fP"
.br
.ti -1c
.RI "bool \fB_activeRender\fP"
.br
.ti -1c
.RI "bool \fB_isSprite\fP"
.br
.ti -1c
.RI "\fBU32\fP \fB_ID\fP"
.br
.ti -1c
.RI "GLuint \fB_vao\fP"
.br
.ti -1c
.RI "GLuint \fB_vbo\fP [NUM_VBO]"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBU32\fP \fB_nextID\fP = 1"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBGameObject\fP may be the backbone of Tempest\&. This is the basic object that will exist in the game\&. It is the root of all rendered and interactive objects in the games\&. It is not a manager\&. This is an abstract class, so it is meant to be full implemented as needed\&. This holds the generic ideas of what makes up the most basic type of Object in the game \fBLevel\fP\&. 
.SH "Member Function Documentation"
.PP 
.SS "const \fBTM::Matrix4\fP& Tempest::GameObject::GetModelMatrix (void) const\fC [inline]\fP"
Returns the 'view' matrix, the transform needed to get the object transformed into world space\&. This is used by opengl for rendering\&. 
.SS "const \fBTM::Matrix4\fP Tempest::GameObject::GetModelMatrixRot (void) const\fC [inline]\fP"
A temporary experiment meant to return the 'view' matrix, with the rotations\&. This is a first attempt to make rotations work, but it didn't really work out very well\&. Issue #51 should fix this\&. 
.SS "void GameObject::LoadMesh (string filepath)"
Loads model from a \&.dae file\&. This does not work at all\&. I have considered removing it completely\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilepath\fP is the file to be loaded\&. 
.RE
.PP

.SS "bool GameObject::LoadOBJ (string filepath)"
Loads a model from a wavefront object (\&.obj file)\&. I would call this a hacked version of file processing, but it does work\&. 
.br
\fBParameters:\fP
.RS 4
\fIfilepath\fP is the path to the model to be loaded\&. 
.RE
.PP

.SS "void GameObject::UpdateInternals (void)"
Calls _CalculateCachedData\&. The idea is that the data for the Object can be cached, and this updates that cache\&. This has some issues since it is not always called\&. 
.SS "void GameObject::v_InitBuffers (void)\fC [virtual]\fP"
By default, this will create a 6 point box, used in sprites\&. It can be overloaded if you need something different in your buffer\&. 
.SS "void GameObject::v_Render (void)\fC [virtual]\fP"
Default Render will check if there is a texture attached to the Object, make the shader on the object active, and will send the vertices that have been added to the object to OpenGL using glDrawArrays\&. This is virtual because it can be overloaded if this is not what you need for rendering\&. 
.PP
Reimplemented in \fBTempest::Glyph\fP\&.
.SS "virtual void Tempest::GameObject::v_Update (void)\fC [pure virtual]\fP"
Abstract function\&. This update is called one per frame, if the object is registered with the GameObjectManager and is Update Active\&. 
.PP
Implemented in \fBTempest::Glyph\fP, and \fBTempest::EnvironmentObject\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Tempest from the source code\&.

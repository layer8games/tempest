.TH "KillerEngine::AudioClip" 3 "Mon Jun 24 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerEngine::AudioClip
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <AudioClip\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAudioClip\fP (void)"
.br
.ti -1c
.RI "\fB~AudioClip\fP (void)"
.br
.ti -1c
.RI "void \fBLoadWAV\fP (string filename)"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetBufferID\fP (void) const"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetChannels\fP (void) const"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetSampleRate\fP (void) const"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetBPS\fP (void) const"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetSize\fP (void) const"
.br
.ti -1c
.RI "const \fBU32\fP \fBGetALFormat\fP (void) const"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBHeaderOffsets\fP { \fBNUM_CHANNELS_OFFSET\fP = 6, \fBCHANNELS_SIZE\fP = 2, \fBSAMPLE_RATE_OFFSET\fP = 8, \fBSAMPLE_RATE_SIZE\fP = 4, \fBBPS_OFFSET\fP = 18, \fBBPS_SIZE\fP = 2, \fBLIST_SIZE\fP = 2, \fBDATA_SIZE\fP = 4 }"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fB_IsBigEndian\fP (void)"
.br
.ti -1c
.RI "\fBU32\fP \fB_ConvertToInt\fP (char *buffer, int len)"
.br
.ti -1c
.RI "void \fB_GetIndexRange\fP (char *source, char *dest, int offset, int len)"
.br
.ti -1c
.RI "void \fB_SetALFormat\fP (void)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBU32\fP \fB_bufferID\fP"
.br
.RI "OpenAL buffer handle\&. This is the ID OpenAL uses, similar to OpenGL's handles\&. "
.ti -1c
.RI "\fBU32\fP \fB_channels\fP"
.br
.RI "Number of channels the audio file has\&. "
.ti -1c
.RI "\fBU32\fP \fB_sampleRate\fP"
.br
.RI "Sample play rate for the file\&. "
.ti -1c
.RI "\fBU32\fP \fB_bps\fP"
.br
.RI "Byte rate for the file\&. "
.ti -1c
.RI "\fBU32\fP \fB_size\fP"
.br
.RI "Size of the audio portion of the file\&. "
.ti -1c
.RI "\fBU32\fP \fB_alFormat\fP"
.br
.RI "Format marker OpenAL uses to determine how to play the file\&. "
.ti -1c
.RI "char * \fB_data\fP"
.br
.RI "Data buffer for the file\&. This is the full file, headers included\&. "
.in -1c
.SH "Detailed Description"
.PP 
A wrapper around an OpenAL audio buffer\&. This stores a clip of audio that, after added to an \fBAudioSource\fP, can be played\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AudioClip::AudioClip (void)"
Calls \fBAudioManager::Instance\fP to make sure that the context and device has been set up in OpenAL before use\&. 
.SS "AudioClip::~AudioClip (void)"
Calls delete[] on the data array to free that resource\&. Deletes the buffer handle from OpenAL\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBU32\fP AudioClip::_ConvertToInt (char * buffer, int len)\fC [private]\fP"
Converts a bit buffer of a set length into its integar equivalent\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP are the bits to convert\&. 
.br
\fIlen\fP is the size of the buffer\&. This must match what you are expecting! 
.RE
.PP

.SS "void AudioClip::_GetIndexRange (char * source, char * dest, int offset, int len)\fC [private]\fP"
An ad hoc solution to array slicing\&. It returns into the destination the elements of the source array from an offset by a set amount\&. For example, if source is an array with 100 elements, and offset is 10, with len being 10, then dest will be source elements 10 through 20\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP is the original array we are slicing into\&. 
.br
\fIdest\fP is where the sub array from source will be stores\&. 
.br
\fIoffset\fP is how far into source to start slicing\&. 
.br
\fIlen\fP is how many elements past offset to slice into dest\&. 
.RE
.PP

.SS "bool KillerEngine::AudioClip::_IsBigEndian (void)\fC [inline]\fP, \fC [private]\fP"
Used to test how the bits of an int are arranged in the internal format of the machine the code is running on\&. Returns true if the machine is Big Endian, false if it is Little Endian\&. https://en.wikipedia.org/wiki/Endianness 
.SS "void AudioClip::_SetALFormat (void)\fC [private]\fP"
Reads the internal members to determine what the AL Format is\&. If no file has been loaded, then _alFormat will be set to 0; 
.SS "const \fBU32\fP KillerEngine::AudioClip::GetALFormat (void) const\fC [inline]\fP"
Returns the internal format that OpenAL uses to idenify the clip\&. Will be 0 by default\&. 
.SS "const \fBU32\fP KillerEngine::AudioClip::GetBPS (void) const\fC [inline]\fP"
Returns the bit rate of the file\&. 0 by default\&. This will be either 8 or 16, usually\&. 
.SS "const \fBU32\fP KillerEngine::AudioClip::GetBufferID (void) const\fC [inline]\fP"
Returns the buffer handle from OpenAL\&. 
.SS "const \fBU32\fP KillerEngine::AudioClip::GetChannels (void) const\fC [inline]\fP"
Returns the number of channels the audio file has\&. 0 by default\&. Usually this will be 1 for mono and 2 for stereo\&. 
.SS "const \fBU32\fP KillerEngine::AudioClip::GetSampleRate (void) const\fC [inline]\fP"
Returns the sample rate the audio file has\&. 0 by default\&. This represents the frequency of the audio file, usually it will be 44100 for most \&.wav files\&. 
.SS "const \fBU32\fP KillerEngine::AudioClip::GetSize (void) const\fC [inline]\fP"
Returns the size in bits of the audio part of the file (does not include headers)\&. 0 by default\&. This number should be pretty big\&. 
.SS "void AudioClip::LoadWAV (string filename)"
Reads a \&.wav file from the hard drive\&. Parses over the file extracting needed information from the headers, then saves the audio file in a buffer that is registered with OpenAL\&. This is used later to actually play back the file\&. This is where all the magic happens\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP is the path to the file to be read\&. Should live in \&.\&./Assets/Audio by convention\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

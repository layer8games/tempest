.TH "KillerMath::Matrix" 3 "Wed Feb 13 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Matrix
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Matrix\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMatrix\fP (void)"
.br
.ti -1c
.RI "\fBMatrix\fP (const \fBVector\fP &x, const \fBVector\fP &y, const \fBVector\fP &z)"
.br
.ti -1c
.RI "\fBMatrix\fP (const \fBVector\fP &x, const \fBVector\fP &y, const \fBVector\fP &z, const \fBVector\fP &w)"
.br
.ti -1c
.RI "\fBMatrix\fP (const \fBF32\fP val)"
.br
.ti -1c
.RI "\fBMatrix\fP (\fBF32\fP m00, \fBF32\fP m01, \fBF32\fP m02, \fBF32\fP m03, \fBF32\fP m10, \fBF32\fP m11, \fBF32\fP m12, \fBF32\fP m13, \fBF32\fP m20, \fBF32\fP m21, \fBF32\fP m22, \fBF32\fP m23, \fBF32\fP m30, \fBF32\fP m31, \fBF32\fP m32, \fBF32\fP m33)"
.br
.ti -1c
.RI "\fBMatrix\fP (const \fBMatrix\fP &M)"
.br
.ti -1c
.RI "const std::vector< \fBF32\fP > \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBMakeOrthographic\fP (\fBF32\fP left, \fBF32\fP right, \fBF32\fP bottom, \fBF32\fP top, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
.br
.ti -1c
.RI "void \fBMakePerspective\fP (\fBF32\fP fieldOfView, \fBF32\fP aspectRatio, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
.br
.ti -1c
.RI "void \fBSetTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetTranslate\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "void \fBAddTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBAddTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddTranslate\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "\fBVector\fP \fBTransformInverse\fP (const \fBVector\fP vec) const"
.br
.ti -1c
.RI "\fBVector\fP \fBTransformDirection\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "\fBVector\fP \fBTransformInverseDirection\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "void \fBAddScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBAddScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScale\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "void \fBSetRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddRotation\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (const \fBQuaternion\fP &q)"
.br
.ti -1c
.RI "void \fBSetOrientationAndPosition\fP (const \fBQuaternion\fP &q, const \fBVector\fP &v)"
.br
.ti -1c
.RI "void \fBSetInverse\fP (void)"
.br
.ti -1c
.RI "void \fBSetAsInverse\fP (const \fBMatrix\fP &mat)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBGetInverse\fP (void) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDeterminate\fP (void) const"
.br
.ti -1c
.RI "void \fBMakeIdentity\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (\fBF32\fP val=0\&.0f)"
.br
.ti -1c
.RI "void \fBTranspose\fP (void)"
.br
.ti -1c
.RI "void \fBComponentMulti\fP (const \fBMatrix\fP &M)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBTransform3x3\fP (const \fBMatrix\fP &mat) const"
.br
.ti -1c
.RI "\fBVector\fP \fBTransform3x3\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "void \fBSetLookAt\fP (const \fBVector\fP &cameraPos, const \fBVector\fP &target, const \fBVector\fP &up)"
.br
.ti -1c
.RI "void \fBSetFPSView\fP (const \fBVector\fP &cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)"
.br
.ti -1c
.RI "const \fBVector\fP & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "\fBVector\fP & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBMatrix\fP & \fBoperator=\fP (const \fBMatrix\fP &mat)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBoperator*\fP (const \fBMatrix\fP &mat) const"
.br
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (const \fBVector\fP &vec) const"
.br
.ti -1c
.RI "\fBMatrix\fP & \fBoperator/=\fP (\fBF32\fP val)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBMatrix\fP \fBTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBTranslate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBTranslate\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "static \fBVector\fP \fBLocalToWorld\fP (const \fBVector\fP &vec, const \fBMatrix\fP &mat)"
.br
.ti -1c
.RI "static \fBVector\fP \fBWorldToLocal\fP (const \fBVector\fP &vec, const \fBMatrix\fP &mat)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBScale\fP (const \fBVector\fP &vec)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBF32\fP \fBDeterminate3x3\fP (\fBVector\fP &col1, \fBVector\fP &col2, \fBVector\fP &col3)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBLookAt\fP (const \fBVector\fP &cameraPos, const \fBVector\fP &target, const \fBVector\fP &up)"
.br
.ti -1c
.RI "static \fBMatrix\fP \fBFPSView\fP (const \fBVector\fP &cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBx\fP =0, \fBy\fP =1, \fBz\fP =2, \fBw\fP =3 }"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBVector\fP \fB_columns\fP [4]"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBMatrix\fP is meant to be mathematically sound\&. The functions found here have been tested and are built according to linear algebra rules\&. The
.PP
Matrices will be column major to ahdere to the format used within opengl, and only 4x4 Matrices will be supported\&. This is because I cannot find any useful reason to suport a dynamic type at this time\&. In the future if other Matrices appear to be useful, this class will basically be copied and will be turned into whatever other type of \fBMatrix\fP is needed, be it a 3x3 or 2x2 or whatever\&. This class will only be a 4x4\&.
.PP
All of the values in the \fBMatrix\fP are stores as a 16 length array of F32\&. This is a single dimensional array\&.
.PP
This is the way that the array mapping looks, for a quick reference\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Matrix::Matrix (void)"
Default constructor\&. Sets all values to 0, except for the last in the \fBMatrix\fP\&. 
.SS "Matrix::Matrix (\fBF32\fP m00, \fBF32\fP m01, \fBF32\fP m02, \fBF32\fP m03, \fBF32\fP m10, \fBF32\fP m11, \fBF32\fP m12, \fBF32\fP m13, \fBF32\fP m20, \fBF32\fP m21, \fBF32\fP m22, \fBF32\fP m23, \fBF32\fP m30, \fBF32\fP m31, \fBF32\fP m32, \fBF32\fP m33)"
All value constructor\&. Takes a list of values and turns them into a matrix of the same mapping\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm00\fP F32\&. Value 0,0\&. 
.br
\fIm01\fP F32\&. Value 0,1\&. 
.br
\fIm02\fP F32\&. Value 0,2 
.br
\fIm03\fP F32\&. Value 0,3\&. 
.br
\fIm10\fP F32\&. Value 1,0\&. 
.br
\fIm11\fP F32\&. Value 1,1\&. 
.br
\fIm12\fP F32\&. Value 1,2 
.br
\fIm13\fP F32\&. Value 1,3\&. 
.br
\fIm20\fP F32\&. Value 2,0\&. 
.br
\fIm21\fP F32\&. Value 2,1\&. 
.br
\fIm22\fP F32\&. Value 2,2 
.br
\fIm23\fP F32\&. Value 2,3\&. 
.br
\fIm30\fP F32\&. Value 3,0\&. 
.br
\fIm31\fP F32\&. Value 3,1\&. 
.br
\fIm32\fP F32\&. Value 3,2 
.br
\fIm33\fP F32\&. Value 3,3\&. 
.RE
.PP

.SS "Matrix::Matrix (const \fBMatrix\fP & M)"
Copy Constructor\&. Calls \fBGetElems()\fP, then sets the values accordingly\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Matrix::AddRotateX (\fBF32\fP val)"
Creates rotation around the x axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::AddRotateY (\fBF32\fP val)"
Creates rotation around the y axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIy\fP F32\&. Degree of rotation around y axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::AddRotateZ (\fBF32\fP val)"
Creates rotation around the z axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIz\fP F32\&. Degree of rotation around z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::AddRotation (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Creates rotation around the x, y and z axis, in that order, without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Not working at all\&. The math is wrong, and rotations are not working in general\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around the x axis\&. Calls \fBRADIAN()\fP 
.br
\fIy\fP F32\&. Degree of rotation around the y axis\&. Calls \fBRADIAN()\fP 
.br
\fIz\fP F32\&. Degree of rotation around the z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::AddScale (\fBF32\fP xVal, \fBF32\fP yVal)"
Creates a scaling \fBMatrix\fP on the x and y axes without resetting the other values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Value of scale on x axis\&. 
.br
\fIy\fP F32\&. Value of scale on y axis\&. 
.RE
.PP

.SS "void Matrix::AddScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Creates a scaling \fBMatrix\fP on the x, y and z axes without resetting the other values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Value of scale on x axis\&. 
.br
\fIy\fP F32\&. Value of scale on y axis\&. 
.br
\fIz\fP F32\&. Value of scale on z axis\&. 
.RE
.PP

.SS "void Matrix::AddScale (const \fBVector\fP & vec)"
Creates a scaling \fBMatrix\fP on the x, y and z axes without resetting the other values\&. 
.SS "void Matrix::AddTranslate (\fBF32\fP xVal, \fBF32\fP yVal)"
Creates a translation on the x and y axes without reseting the other values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Value of x axis translation\&. 
.br
\fIy\fP F32\&. Value of y axis translation\&. 
.RE
.PP

.SS "void Matrix::AddTranslate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Creates a translation on the x, y and z axes without resetting the other values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Value of x axis translation\&. 
.br
\fIy\fP F32\&. Value of y axis translation\&. 
.br
\fIz\fP F32\&. Value of z axis translation\&. 
.RE
.PP

.SS "void Matrix::AddTranslate (const \fBVector\fP & vec)"
Creates a translation on the x, y and z axes without reseting the other values\&. 
.SS "void Matrix::ComponentMulti (const \fBMatrix\fP & M)"
Also known as a straight multiplication\&. Multiplies each value of this \fBMatrix\fP by the matching value of M\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP \fBMatrix\fP&\&. Right hand value to multiply by\&. 
.RE
.PP

.SS "const std::vector< \fBF32\fP > Matrix::GetElems (void) const"
Return the array containing all the elements\&. 
.SS "void KillerMath::Matrix::MakeIdentity (void)\fC [inline]\fP"
Wrapper for \fBReset()\fP\&. Sets all values of the \fBMatrix\fP to 0, with the diagnal set to 1\&. 
.SS "void Matrix::MakeOrthographic (\fBF32\fP left, \fBF32\fP right, \fBF32\fP bottom, \fBF32\fP top, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
Resets the \fBMatrix\fP, then sets the values up as an Orthographic projection\&. Calls MakeIdentiy()\&. The viewport values are usually based on the dimensions of the window, but could be made smaller\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP F32\&. Width of viewport\&. 
.br
\fIheight\fP F32\&. Height of viewport\&. 
.br
\fIdepth\fP F32\&. Depth of the viewport\&. 
.br
\fIcenter\fP bool\&. Set to true by default\&. If true, the origin of the view port will be the middle of the screen\&. Otherwise it will be the bottom left corner of the screen\&. 
.RE
.PP

.SS "void Matrix::MakePerspective (\fBF32\fP fieldOfView, \fBF32\fP aspectRatio, \fBF32\fP nearPlane, \fBF32\fP farPlane)"
Resets the \fBMatrix\fP, then sets the values up as a Perspective \fBMatrix\fP\&. Instead of using the dimensions of the viewport, this version uses slightly differently ideas\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfieldOfview\fP F32\&. Angle of the view fields of view\&. Good values include 90 or 120\&. Will change the skew of the view\&. 
.br
\fIaspectration\fP F32\&. Width/height of the screen, but can be set to more specifici values like 4:3 or 16:9\&. 
.br
\fInearPlane\fP F32\&. Near rendering plane of viewport\&. Must be at least 1\&.0f\&. 
.br
\fIfarPlane\fP F32\&. Similar to depth, this is the point at which culling will happen\&. Should be greater than nearPlane\&. 
.RE
.PP

.SS "\fBMatrix\fP Matrix::operator* (const \fBMatrix\fP & mat) const"
Performs a \fBMatrix\fP style multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIRightMatrix\fP \fBMatrix\fP&\&. Right hand value for multiplication\&. 
.RE
.PP

.SS "\fBVector\fP Matrix::operator* (const \fBVector\fP & vec) const"
Performs \fBMatrix\fP multiplication with \fBVector\fP\&. 
.SS "\fBMatrix\fP & Matrix::operator= (const \fBMatrix\fP & mat)"
Sets all the values of object to values of M\&. Call \fBGetElems()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP \fBMatrix\fP& 
.RE
.PP

.SS "const \fBVector\fP& KillerMath::Matrix::operator[] (int i) const\fC [inline]\fP"
Used to access the ith column of the matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP int\&. Cannot be greater than 3\&. There are only 4 columns\&. 
.RE
.PP

.SS "\fBVector\fP& KillerMath::Matrix::operator[] (int i)\fC [inline]\fP"
Used to access the ith column of the matrix\&. This version allows you to edit the values in the column\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP int\&. Cannot be greater than 3\&. There are only 4 columns\&. 
.RE
.PP

.SS "void Matrix::Reset (\fBF32\fP val = \fC0\&.0f\fP)"
Sets all the values of the \fBMatrix\fP to 0, with the diagnal set to val\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP F32\&. Value of the diagnal of the \fBMatrix\fP\&. 
.RE
.PP

.SS "void Matrix::SetFPSView (const \fBVector\fP & cameraPos, \fBF32\fP pitch, \fBF32\fP yaw)"
Uses Euler angles to compute a view matrix from the world position\&. This assumes a Right Handed Coordinate system\&. This means that the camera, by default at 0\&.0 is looking down the -z axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcameraPos\fP \fBVector\fP&\&. The position of the camera in world space\&. Can be thought of as the eye\&. 
.br
\fIpitch\fP F32\&. Must be between -90 and 90\&. An assert checks for this\&. 
.br
\fIyaw\fP F32\&. Must be between 0 and 360\&. An assert checks for thisl 
.RE
.PP

.SS "void Matrix::SetLookAt (const \fBVector\fP & cameraPos, const \fBVector\fP & target, const \fBVector\fP & up)"
Creates a view matrix from the world position\&. Will set the view to 'look at' the specified point\&. This assumes a Right Handed Coordinate system\&. This means that the camera, by default at 0\&.0 is looking down the -z axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcameraPos\fP \fBVector\fP&\&. The world position of the camera\&. Can be thought of as the eye\&. 
.br
\fItarget\fP \fBVector\fP&\&. The target point to 'look at'\&. 
.br
\fIup\fP \fBVector\fP&\&. The direction of UP space in the coordinate scheme\&. could be +y, for example\&. 
.RE
.PP

.SS "void Matrix::SetRotate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Resets the \fBMatrix\fP and creates an \fBMatrix\fP which will perform a rotation around the x, y and z axis in that order\&. Calls \fBMakeIdentity()\fP 
.PP
\fBBug\fP
.RS 4
Not working at all\&. The math is wrong, and rotations are not working in general\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around the x axis\&. Calls \fBRADIAN()\fP 
.br
\fIy\fP F32\&. Degree of rotation around the y axis\&. Calls \fBRADIAN()\fP 
.br
\fIz\fP F32\&. Degree of rotation around the z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::SetRotateX (\fBF32\fP val)"
Resets \fBMatrix\fP and creates rotation around the x axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::SetRotateY (\fBF32\fP val)"
Resets \fBMatrix\fP and creates rotation around the y axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIy\fP F32\&. Degree of rotation around y axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::SetRotateZ (\fBF32\fP val)"
Resets \fBMatrix\fP and creates rotation around the z axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIz\fP F32\&. Degree of rotation around z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix::SetScale (\fBF32\fP xVal, \fBF32\fP yVal)"
Resets the \fBMatrix\fP and creates a scaling \fBMatrix\fP on the x and y axes\&. Calls MakeIndentity() 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Length to scale on x axis\&. 
.br
\fIy\fP F32\&. Length to scale on y axis\&. 
.RE
.PP

.SS "void Matrix::SetScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Resets the \fBMatrix\fP and creates a scaling \fBMatrix\fP on the x, y and z axes\&. MakeIndentity() 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Length to scale on the x axis\&. 
.br
\fIy\fP F32\&. Length to scale on the y axis\&. 
.br
\fIz\fP F32\&. Length to scale on the z axis\&. 
.RE
.PP

.SS "void Matrix::SetScale (const \fBVector\fP & vec)"
Resets the \fBMatrix\fP and creates a scaling \fBMatrix\fP on the x and y axes\&. Calls MakeIndentity()\&. 
.SS "void Matrix::SetTranslate (\fBF32\fP xVal, \fBF32\fP yVal)"
Resets \fBMatrix\fP, then creates a Translation on the x and y axes\&. Calls MakeIdentiy()\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Value of x axis translation\&. 
.br
\fIy\fP F32\&. Value of y axis translation\&. 
.RE
.PP

.SS "void Matrix::SetTranslate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Resets \fBMatrix\fP, thn creates a Translation on the x, y and z axes\&. Calls MakeIdentiy()\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Value of x axis translation\&. 
.br
\fIy\fP F32\&. Value of y axis translation\&. 
.br
\fIz\fP F32\&. Value of z axis translation\&. 
.RE
.PP

.SS "void Matrix::SetTranslate (const \fBVector\fP & vec)"
Resets \fBMatrix\fP, then creates translation based on the x, y and z values found in vec\&. Calls MakeIdentiy()\&. 
.SS "void Matrix::Transpose (void)"
Reverses the Column/Row order of the \fBMatrix\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.

.TH "KillerMath::Matrix3" 3 "Mon Apr 22 2019" "Killer Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KillerMath::Matrix3
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Matrix3\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMatrix3\fP (void)"
.br
.ti -1c
.RI "\fBMatrix3\fP (const \fBVector3\fP &x, const \fBVector3\fP &y, const \fBVector3\fP &z)"
.br
.ti -1c
.RI "\fBMatrix3\fP (const \fBVector4\fP &x, const \fBVector4\fP &y, const \fBVector4\fP &z)"
.br
.ti -1c
.RI "\fBMatrix3\fP (const \fBF32\fP val)"
.br
.ti -1c
.RI "\fBMatrix3\fP (\fBF32\fP m00, \fBF32\fP m01, \fBF32\fP m02, \fBF32\fP m10, \fBF32\fP m11, \fBF32\fP m12, \fBF32\fP m20, \fBF32\fP m21, \fBF32\fP m22)"
.br
.ti -1c
.RI "\fBMatrix3\fP (const \fBMatrix3\fP &M)"
.br
.ti -1c
.RI "const std::vector< \fBF32\fP > \fBGetElems\fP (void) const"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetScale\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "void \fBSetScale\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "void \fBAddScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "void \fBAddScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddScale\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "void \fBAddScale\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "void \fBSetRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBAddRotateZ\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "void \fBSetRotate\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBAddRotation\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "void \fBSetOrientation\fP (const \fBQuaternion\fP &q)"
.br
.ti -1c
.RI "void \fBSetInverse\fP (void)"
.br
.ti -1c
.RI "void \fBSetAsInverse\fP (const \fBMatrix3\fP &mat)"
.br
.ti -1c
.RI "\fBMatrix3\fP \fBGetInverse\fP (void) const"
.br
.ti -1c
.RI "\fBF32\fP \fBDeterminate\fP (void) const"
.br
.ti -1c
.RI "void \fBMakeIdentity\fP (void)"
.br
.ti -1c
.RI "void \fBReset\fP (\fBF32\fP val=0\&.0f)"
.br
.ti -1c
.RI "void \fBTranspose\fP (void)"
.br
.ti -1c
.RI "void \fBComponentMulti\fP (const \fBMatrix3\fP &M)"
.br
.ti -1c
.RI "\fBMatrix3\fP \fBMatrix3::Transform\fP (const \fBMatrix3\fP &mat) const"
.br
.ti -1c
.RI "\fBVector4\fP \fBMatrix3::Transform\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "const \fBVector3\fP & \fBoperator[]\fP (int i) const"
.br
.ti -1c
.RI "\fBVector3\fP & \fBoperator[]\fP (int i)"
.br
.ti -1c
.RI "\fBMatrix3\fP & \fBoperator=\fP (const \fBMatrix3\fP &mat)"
.br
.ti -1c
.RI "\fBMatrix3\fP \fBoperator*\fP (const \fBMatrix3\fP &mat) const"
.br
.ti -1c
.RI "\fBVector4\fP \fBoperator*\fP (const \fBVector4\fP &vec) const"
.br
.ti -1c
.RI "\fBMatrix3\fP & \fBoperator/=\fP (\fBF32\fP val)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBMatrix3\fP \fBScale\fP (\fBF32\fP xVal, \fBF32\fP yVal)"
.br
.ti -1c
.RI "static \fBMatrix3\fP \fBScale\fP (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
.br
.ti -1c
.RI "static \fBMatrix3\fP \fBScale\fP (const \fBVector3\fP &vec)"
.br
.ti -1c
.RI "static \fBMatrix3\fP \fBScale\fP (const \fBVector4\fP &vec)"
.br
.ti -1c
.RI "static \fBMatrix3\fP \fBRotateX\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix3\fP \fBRotateY\fP (\fBF32\fP val)"
.br
.ti -1c
.RI "static \fBMatrix3\fP \fBRotateZ\fP (\fBF32\fP val)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBF32\fP \fB_Cofactor\fP (\fBF32\fP c00, \fBF32\fP c01, \fBF32\fP c10, \fBF32\fP c11) const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBVector3\fP \fB_data\fP [3]"
.br
.RI "The matrix itself, represented by 3 Vector43in an array\&. "
.in -1c
.SH "Detailed Description"
.PP 
The \fBMatrix3\fP is a 3x3 Matrix meant to be mathematically sound\&. The functions found here have been tested and are built according to linear algebra rules\&. The Matrices are column major to adhere to the format used within OpenGL\&.
.PP
The data for the class is represented by an array of \fBVector4\fP\&. This means that you can index into a specific element of the Matrix, say, colume 2, row 1 by using [2][1]\&. In the rest of the this documentation, this type of value will be represented by the term mrowcolumn\&. For example, colum 2, row 1 will look like m21, read m two one\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Matrix3::Matrix3 (void)"
Default constructor\&. Sets all values to 0\&. 
.SS "Matrix3::Matrix3 (\fBF32\fP m00, \fBF32\fP m01, \fBF32\fP m02, \fBF32\fP m10, \fBF32\fP m11, \fBF32\fP m12, \fBF32\fP m20, \fBF32\fP m21, \fBF32\fP m22)"
All value constructor\&. Takes a list of values and turns them into a \fBMatrix3\fP of the same mapping\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm00\fP is the value for element m00\&. 
.br
\fIm01\fP is the value for element m01\&. 
.br
\fIm02\fP is the value for element m02 
.br
\fIm10\fP is the value for element m10\&. 
.br
\fIm11\fP is the value for element m11\&. 
.br
\fIm12\fP is the value for element m12 
.br
\fIm20\fP is the value for element m20\&. 
.br
\fIm21\fP is the value for element m21\&. 
.br
\fIm22\fP is the value for element m22 
.RE
.PP

.SS "Matrix3::Matrix3 (const \fBMatrix3\fP & M)"
Copy Constructor\&. Calls \fBMatrix3\fP::[] to, which will copy the \fBVector4\fP from each colume of M into this Matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP is the matrix to copy into this one\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "\fBF32\fP Matrix3::_Cofactor (\fBF32\fP c00, \fBF32\fP c01, \fBF32\fP c10, \fBF32\fP c11) const\fC [private]\fP"
Returns the cofactor for the sub matrix made up of the 3 \fBVector4\fP passed in\&. This is used in Matrix4::Inverse as part of what is called a Classic Adjoint\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc00\fP is the first element of the first column of the sub matrix\&. 
.br
\fIc01\fP is the second element of the first column of the sub matrix\&. 
.br
\fIc10\fP is the first element of the second column of the sub matrix\&. 
.br
\fIc11\fP is the second element of the second column of the sub matrix\&. 
.RE
.PP

.SS "void Matrix3::AddRotateX (\fBF32\fP val)"
Creates rotation around the x axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::AddRotateY (\fBF32\fP val)"
Creates rotation around the x axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::AddRotateZ (\fBF32\fP val)"
Creates rotation around the z axis without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Completely untested and probably not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIz\fP F32\&. Degree of rotation around z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::AddRotation (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Creates rotation around the x, y and z axis, in that order, without resetting other values\&. 
.PP
\fBBug\fP
.RS 4
Not working at all\&. The math is wrong, and rotations are not working in general\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around the x axis\&. Calls \fBRADIAN()\fP 
.br
\fIy\fP F32\&. Degree of rotation around the y axis\&. Calls \fBRADIAN()\fP 
.br
\fIz\fP F32\&. Degree of rotation around the z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::AddScale (\fBF32\fP xVal, \fBF32\fP yVal)"
Increases the scaling translation in 2D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Value of scale on x axis\&. 
.br
\fIy\fP Value of scale on y axis\&. 
.RE
.PP

.SS "void Matrix3::AddScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Increases the scaling translation in 3D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Value of scale on x axis\&. 
.br
\fIy\fP Value of scale on y axis\&. 
.br
\fIz\fP Value of scale on z axis\&. 
.RE
.PP

.SS "void Matrix3::AddScale (const \fBVector3\fP & vec)"
Increases the scaling translation equal to the x y and z values in a \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values that will increase the scale\&. 
.RE
.PP

.SS "void Matrix3::AddScale (const \fBVector4\fP & vec)"
Increases the scaling translation equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values that will increase the scale\&. 
.RE
.PP

.SS "void Matrix3::ComponentMulti (const \fBMatrix3\fP & M)"
Also known as a straight multiplication\&. Multiplies each value of this \fBMatrix4\fP by the matching value of M\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP \fBMatrix4\fP&\&. Right hand value to multiply by\&. 
.RE
.PP

.SS "\fBF32\fP Matrix3::Determinate (void) const"
Returns the determinate of this matrix\&. This has many uses, and if you are not sure what a determinate is, I have a lot of books you can read\&.\&.\&. 
.SS "const std::vector< \fBF32\fP > Matrix3::GetElems (void) const"
Return the array containing all the elements\&. 
.SS "\fBMatrix3\fP Matrix3::GetInverse (void) const"
Returns a matrix that is the inverse of this one\&. Warning, very expensive function to call\&. 
.SS "void KillerMath::Matrix3::MakeIdentity (void)\fC [inline]\fP"
Sets all values of the \fBMatrix4\fP to 0, with the diagnal set to 1\&. 
.SS "\fBMatrix3\fP KillerMath::Matrix3::Matrix3::Transform (const \fBMatrix3\fP & mat) const"
Helper function that will return the transformed version of a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP is transformed\&. 
.RE
.PP

.SS "\fBVector4\fP KillerMath::Matrix3::Matrix3::Transform (const \fBVector4\fP & vec) const"
Helper function that will return the transformed version of a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is transformed\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::operator* (const \fBMatrix3\fP & mat) const"
Performs a \fBMatrix4\fP style multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP is the matrix that is multiplied by this matrix\&. 
.RE
.PP

.SS "\fBVector4\fP Matrix3::operator* (const \fBVector4\fP & vec) const"
Performs \fBMatrix4\fP multiplication with \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP is the vector that is multiplied by this matrix\&. 
.RE
.PP

.SS "\fBMatrix3\fP & Matrix3::operator/= (\fBF32\fP val)"
Divides each element of this matrix, setting it to the results\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the value that this matrix is divided by\&. 
.RE
.PP

.SS "\fBMatrix3\fP & Matrix3::operator= (const \fBMatrix3\fP & mat)"
Assigns this matrix to be equal to the values of another\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP is the matrix that is copied\&. 
.RE
.PP

.SS "const \fBVector3\fP& KillerMath::Matrix3::operator[] (int i) const\fC [inline]\fP"
Used to access the ith column of the \fBMatrix4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index to return\&. Cannot be greater than 3\&. There are only 4 columns\&. 
.RE
.PP

.SS "\fBVector3\fP& KillerMath::Matrix3::operator[] (int i)\fC [inline]\fP"
Used to access the ith column of the \fBMatrix4\fP\&. This version allows you to edit the values in the column\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP is the index to return\&. Cannot be greater than 3\&. There are only 4 columns\&. 
.RE
.PP

.SS "void Matrix3::Reset (\fBF32\fP val = \fC0\&.0f\fP)"
Sets all the values of the \fBMatrix4\fP to 0, with the diagnal set to val\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Value of the diagnal of the \fBMatrix4\fP\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::RotateX (\fBF32\fP val)\fC [static]\fP"
Creates a matrix that will perform a rotation around the x axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the angle to rotate in degrees\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::RotateY (\fBF32\fP val)\fC [static]\fP"
Creates a matrix that will perform a rotation around the y axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the angle to rotate in degrees\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::RotateZ (\fBF32\fP val)\fC [static]\fP"
Creates a matrix that will perform a rotation around the z axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP is the angle to rotate in degrees\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::Scale (\fBF32\fP xVal, \fBF32\fP yVal)\fC [static]\fP"
Creates a matrix that will perform a scaling transformation in 2D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::Scale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)\fC [static]\fP"
Creates a matrix that will perform a scaling transformation in 3D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.br
\fIzVal\fP is the amount to scale in the z axis\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::Scale (const \fBVector3\fP & vec)\fC [static]\fP"
Creates a matrix that will perform a scaling translation equal to the x y and z values in a \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "\fBMatrix3\fP Matrix3::Scale (const \fBVector4\fP & vec)\fC [static]\fP"
Creates a matrix that will perform a scaling translation equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "void Matrix3::SetAsInverse (const \fBMatrix3\fP & mat)"
Changes this matrix to equal the inverse of another\&. Warning, very expsenive function to call\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat\fP inverse will be set to this matrix\&. 
.RE
.PP

.SS "void Matrix3::SetInverse (void)"
Changes this matrix to equal its inverse\&. Warning, this is a very expensive function to call\&. 
.SS "void Matrix3::SetOrientation (const \fBQuaternion\fP & q)"
Sets the rotational transform of the matrix equal to the orientation contained in teh \fBQuaternion\fP\&. This is currently untested\&. 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP conatins the orientation to set\&. 
.RE
.PP

.SS "void Matrix3::SetRotate (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Resets the \fBMatrix3\fP and creates an \fBMatrix3\fP which will perform a rotation around the x, y and z axis in that order\&. Calls \fBMakeIdentity()\fP 
.PP
\fBBug\fP
.RS 4
Not working at all\&. The math is wrong, and rotations are not working in general\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around the x axis\&. Calls \fBRADIAN()\fP 
.br
\fIy\fP F32\&. Degree of rotation around the y axis\&. Calls \fBRADIAN()\fP 
.br
\fIz\fP F32\&. Degree of rotation around the z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::SetRotateX (\fBF32\fP val)"
Resets \fBMatrix3\fP and creates rotation around the x axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP F32\&. Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::SetRotateY (\fBF32\fP val)"
Resets \fBMatrix4\fP and creates rotation around the y axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Degree of rotation around x axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::SetRotateZ (\fBF32\fP val)"
Resets \fBMatrix3\fP and creates rotation around the z axis\&. Call MakeIdentiy()\&. 
.PP
\fBBug\fP
.RS 4
This is not working at all\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIz\fP F32\&. Degree of rotation around z axis\&. Calls \fBRADIAN()\fP 
.RE
.PP

.SS "void Matrix3::SetScale (\fBF32\fP xVal, \fBF32\fP yVal)"
Sets this matrix to perform a scaling transformation in 2D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.RE
.PP

.SS "void Matrix3::SetScale (\fBF32\fP xVal, \fBF32\fP yVal, \fBF32\fP zVal)"
Sets this matrix to perform a scaling transformation in 3D\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxVal\fP is the amount to scale in the x axis\&. 
.br
\fIyVal\fP is the amount to scale in the y axis\&. 
.br
\fIzVal\fP is the amount to scale in the z axis\&. 
.RE
.PP

.SS "void Matrix3::SetScale (const \fBVector3\fP & vec)"
Sets this matrix to perform a scaling translation equal to the x y and z values in a \fBVector3\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "void Matrix3::SetScale (const \fBVector4\fP & vec)"
Sets this matrix to perform a scaling translation equal to the x y and z values in a \fBVector4\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvec\fP contains the values used in the scaling\&. 
.RE
.PP

.SS "void Matrix3::Transpose (void)"
Reverses the Column/Row order of the \fBMatrix3\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Killer Engine from the source code\&.
